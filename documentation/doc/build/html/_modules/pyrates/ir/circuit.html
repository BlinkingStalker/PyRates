
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pyrates.ir.circuit &#8212; PyRates 0.7.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for pyrates.ir.circuit</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># PyRates software framework for flexible implementation of neural </span>
<span class="c1"># network model_templates and simulations. See also:</span>
<span class="c1"># https://github.com/pyrates-neuroscience/PyRates</span>
<span class="c1"># </span>
<span class="c1"># Copyright (C) 2017-2018 the original authors (Richard Gast and </span>
<span class="c1"># Daniel Rose), the Max-Planck-Institute for Human Cognitive Brain </span>
<span class="c1"># Sciences (&quot;MPI CBS&quot;) and contributors</span>
<span class="c1"># </span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1"># </span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1"># </span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;</span>
<span class="c1"># </span>
<span class="c1"># CITATION:</span>
<span class="c1"># </span>
<span class="c1"># Richard Gast and Daniel Rose et. al. in preparation</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">filterwarnings</span>

<span class="kn">from</span> <span class="nn">networkx</span> <span class="k">import</span> <span class="n">MultiDiGraph</span><span class="p">,</span> <span class="n">subgraph</span><span class="p">,</span> <span class="n">DiGraph</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pyrates</span> <span class="k">import</span> <span class="n">PyRatesException</span>
<span class="kn">from</span> <span class="nn">pyrates.ir.node</span> <span class="k">import</span> <span class="n">NodeIR</span><span class="p">,</span> <span class="n">VectorizedNodeIR</span>
<span class="kn">from</span> <span class="nn">pyrates.ir.edge</span> <span class="k">import</span> <span class="n">EdgeIR</span>
<span class="kn">from</span> <span class="nn">pyrates.ir.abc</span> <span class="k">import</span> <span class="n">AbstractBaseIR</span>
<span class="kn">from</span> <span class="nn">pyrates.backend.parser</span> <span class="k">import</span> <span class="n">parse_dict</span><span class="p">,</span> <span class="n">parse_equation_system</span><span class="p">,</span> <span class="n">is_diff_eq</span><span class="p">,</span> <span class="n">replace</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Daniel Rose, Richard Gast&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;Development&quot;</span>


<div class="viewcode-block" id="CircuitIR"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR">[docs]</a><span class="k">class</span> <span class="nc">CircuitIR</span><span class="p">(</span><span class="n">AbstractBaseIR</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Custom graph data structure that represents a backend of nodes and edges with associated equations</span>
<span class="sd">    and variables.&quot;&quot;&quot;</span>

    <span class="c1"># _node_label_grammar = Word(alphanums+&quot;_&quot;) + Suppress(&quot;.&quot;) + Word(nums)</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;label_map&quot;</span><span class="p">,</span> <span class="s2">&quot;graph&quot;</span><span class="p">,</span> <span class="s2">&quot;sub_circuits&quot;</span><span class="p">,</span> <span class="s2">&quot;_reference_map&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;_first_run&quot;</span><span class="p">,</span> <span class="s2">&quot;_vectorized&quot;</span><span class="p">,</span> <span class="s2">&quot;_compile_info&quot;</span><span class="p">,</span> <span class="s2">&quot;_backend&quot;</span><span class="p">,</span> <span class="s2">&quot;_dt&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;circuit&quot;</span><span class="p">,</span> <span class="n">circuits</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NodeIR</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">edges</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        label</span>
<span class="sd">            String label, could be used as fallback when subcircuiting this circuit. Currently not used, though.</span>
<span class="sd">        circuits</span>
<span class="sd">            Dictionary of sub-circuits to be added. Keys are string labels for circuits that serve as namespaces for the</span>
<span class="sd">            subcircuits. Items must be `CircuitIR` instances.</span>
<span class="sd">        nodes</span>
<span class="sd">            Dictionary of nodes of form {node_label: `NodeIR` instance}.</span>
<span class="sd">        edges</span>
<span class="sd">            List of tuples (source:str, target:str, edge_dict). `edge_dict` should contain the key &quot;edge_ir&quot; with an</span>
<span class="sd">            `EdgeIR` instance as item and optionally entries for &quot;weight&quot; and &quot;delay&quot;. `source` and `target` should be</span>
<span class="sd">            formatted as &quot;node/op/var&quot; (with optionally prepended circuits).</span>
<span class="sd">        template</span>
<span class="sd">            optional string reference to path to template that this circuit was loaded from. Leave empty, if no template</span>
<span class="sd">            was used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">MultiDiGraph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">circuits</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">temp</span> <span class="ow">in</span> <span class="n">circuits</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vectorized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compile_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">_collect_references</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_or_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Collect all references of nodes or edges to unique operator_graph instances in local `_reference_map`.</span>
<span class="sd">        References are collected as a list, because nodes and edges are (currently) not hashable.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">op_graph</span> <span class="o">=</span> <span class="n">edge_or_node</span><span class="o">.</span><span class="n">op_graph</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">op_graph</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_or_node</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge_or_node</span><span class="p">]</span>

        <span class="c1"># for key, data in edge_or_node:</span>
        <span class="c1">#     op = data[&quot;operator&quot;]</span>
        <span class="c1">#     try:</span>
        <span class="c1">#         self._reference_map[op].add(op_graph)</span>
        <span class="c1">#     except KeyError:</span>
        <span class="c1">#         self._reference_map[op] = {op_graph}</span>

<div class="viewcode-block" id="CircuitIR.add_nodes_from"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.add_nodes_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NodeIR</span><span class="p">],</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add multiple nodes to circuit. Allows networkx-style adding of nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes</span>
<span class="sd">            Dictionary with node label as key. The item is a NodeIR instance. Note that the item type is not tested</span>
<span class="sd">            here, but passing anything that does not behave like a `NodeIR` may cause problems later.</span>
<span class="sd">        attr</span>
<span class="sd">            additional keyword attributes that can be added to the node data. (default `networkx` syntax.)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get unique labels for nodes  --&gt; deprecated and removed.</span>
        <span class="c1"># for label in nodes:</span>
        <span class="c1">#     self.label_map[label] = self._get_unique_label(label)</span>

        <span class="c1"># collect references to op_graphs in nodes</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collect_references</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># assign NodeIR instances as &quot;node&quot; keys in a separate dictionary, because networkx saves node attributes into</span>
        <span class="c1"># a dictionary</span>
        <span class="c1"># reformat dictionary to tuple/generator, since networkx does not parse dictionary correctly in add_nodes_from</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;node&quot;</span><span class="p">:</span> <span class="n">node</span><span class="p">})</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.add_node"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeIR</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add single node</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label</span>
<span class="sd">            String to identify node by. Is tested for uniqueness internally, and renamed if necessary. Renamed labels</span>
<span class="sd">            are stored in the `CircuitIR` instance attribute `label_map`.</span>
<span class="sd">        node</span>
<span class="sd">            Instance of `NodeIR`. Will be added with the key &quot;node&quot; to the node dictionary.</span>
<span class="sd">        attr</span>
<span class="sd">            Additional attributes (keyword arguments) that can be added to the node data. (Default `networkx` syntax.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>

        <span class="c1"># collect references to op_graph in node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collect_references</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.add_edges_from"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.add_edges_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add multiple edges. This method explicitly assumes, that edges are given in edge_templates instead of</span>
<span class="sd">        existing instances of `EdgeIR`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges</span>
<span class="sd">            List of edges, each of shape [source/op/var, target/op/var, edge_dict]. The edge_dict must contain the</span>
<span class="sd">            keys &quot;edge_ir&quot;, and optionally &quot;weight&quot; and &quot;delay&quot;.</span>
<span class="sd">        attr</span>
<span class="sd">            Additional attributes (keyword arguments) that can be added to the edge data. (Default `networkx` syntax.)</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge_dict</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="c1"># get weight</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">edge_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
            <span class="c1"># get delay</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="n">edge_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># get edge_ir or (if not included) default to an empty edge</span>
            <span class="n">edge_ir</span> <span class="o">=</span> <span class="n">edge_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edge_ir&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;target_var&quot;</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="p">:</span>
                <span class="n">target_var</span> <span class="o">=</span> <span class="n">edge_dict</span><span class="p">[</span><span class="s2">&quot;target_var&quot;</span><span class="p">]</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{target}</span><span class="s2">/</span><span class="si">{target_var}</span><span class="s2">&quot;</span>

            <span class="k">if</span> <span class="s2">&quot;source_var&quot;</span> <span class="ow">in</span> <span class="n">edge_dict</span><span class="p">:</span>
                <span class="n">source_var</span> <span class="o">=</span> <span class="n">edge_dict</span><span class="p">[</span><span class="s2">&quot;source_var&quot;</span><span class="p">]</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{source}</span><span class="s2">/</span><span class="si">{source_var}</span><span class="s2">&quot;</span>

            <span class="c1"># test, if variables at source and target exist and reference them properly</span>
            <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_separate_key_path</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

            <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># edge_unique_key,</span>
                              <span class="p">{</span><span class="s2">&quot;edge_ir&quot;</span><span class="p">:</span> <span class="n">edge_ir</span><span class="p">,</span>
                               <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">weight</span><span class="p">,</span>
                               <span class="s2">&quot;delay&quot;</span><span class="p">:</span> <span class="n">delay</span><span class="p">,</span>
                               <span class="s2">&quot;source_var&quot;</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]),</span>
                               <span class="s2">&quot;target_var&quot;</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
                               <span class="p">}))</span>

            <span class="c1"># collect references to op_graph in edge ir</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collect_references</span><span class="p">(</span><span class="n">edge_ir</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.add_edge"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_ir</span><span class="p">:</span> <span class="n">EdgeIR</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">identify_relations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source</span>
<span class="sd">        target</span>
<span class="sd">        edge_ir</span>
<span class="sd">        weight</span>
<span class="sd">        delay</span>
<span class="sd">        data</span>
<span class="sd">            If no template is given, `data` is assumed to conform to the format that is needed to add an edge. I.e.,</span>
<span class="sd">            `data` needs to contain fields for `weight`, `delay`, `edge_ir`, `source_var`, `target_var`.</span>
<span class="sd">        identify_relations</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">source_var</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">target_var</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">identify_relations</span><span class="p">:</span>
            <span class="c1"># test, if variables at source and target exist and reference them properly</span>
            <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_separate_key_path</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># assume that source and target strings are already consistent. This should be the case,</span>
            <span class="c1"># if the given strings were coming from existing circuits (instances of `CircuitIR`)</span>
            <span class="c1"># or in general, if operators are not renamed.</span>
            <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Failed to add edge, because referenced node `</span><span class="si">{path}</span><span class="s2">` does not exist in &quot;</span>
                                           <span class="n">f</span><span class="s2">&quot;network graph. Edges can only be added to existing nodes.&quot;</span><span class="p">)</span>

            <span class="n">source_var</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;source_var&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">target_var</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;target_var&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>

        <span class="c1"># temporary workaround to make sure source/target variable/operator and nodes are defined properly</span>
        <span class="k">if</span> <span class="n">source_var</span><span class="p">:</span>
            <span class="n">source_node</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source_node</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">source_var</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

        <span class="k">if</span> <span class="n">target_var</span><span class="p">:</span>
            <span class="n">target_node</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_node</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">target_var</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

        <span class="n">attr_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">edge_ir</span><span class="o">=</span><span class="n">edge_ir</span><span class="p">,</span>
                         <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                         <span class="n">delay</span><span class="o">=</span><span class="n">delay</span><span class="p">,</span>
                         <span class="n">source_var</span><span class="o">=</span><span class="n">source_var</span><span class="p">,</span>
                         <span class="n">target_var</span><span class="o">=</span><span class="n">target_var</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="o">**</span><span class="n">attr_dict</span><span class="p">)</span>

        <span class="c1"># collect references to op_graph in edge ir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collect_references</span><span class="p">(</span><span class="n">edge_ir</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_validate_separate_key_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">paths</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="c1"># (circuits), node, operator and variable specifiers</span>

            <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>

            <span class="n">node</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="c1"># TODO: check, whether checking the node label against the label map ist still necessary</span>
            <span class="c1"># re-reference node labels, if necessary</span>
            <span class="c1"># this syntax yields `node` back as default if it is not in label_map</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="c1"># ignore circuits for now</span>
            <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="p">))</span>
            <span class="c1"># check if path is valid</span>
            <span class="k">if</span> <span class="n">path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Could not find object with key path `</span><span class="si">{path}</span><span class="s2">`.&quot;</span><span class="p">)</span>

            <span class="n">separated</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">separated</span>

<div class="viewcode-block" id="CircuitIR.getitem_from_iterator"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.getitem_from_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">getitem_from_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_iter</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">SubCircuitView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;node&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">item</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shortcut to self.graph.nodes. See documentation of `networkx.MultiDiGraph.nodes`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shortcut to self.graph.edges. See documentation of `networkx.MultiDiGraph.edges`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span>

<div class="viewcode-block" id="CircuitIR.from_circuits"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.from_circuits">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_circuits</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">circuits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Circuit creation method that takes multiple circuits (templates or instances of `CircuitIR`) as inputs to</span>
<span class="sd">        create one larger circuit out of these. With additional `connectivity` information, these circuit can directly</span>
<span class="sd">        be interlinked.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label</span>
<span class="sd">            Name of new circuit. Should not collide with any circuit label given in `circuits`.</span>
<span class="sd">        circuits</span>
<span class="sd">            Dictionary with unique circuit labels as keys and circuits as items. Circuits may either be instances of</span>
<span class="sd">            `CircuitTemplate` or `CircuitIR`. Alternatively, a circuit template may also be given via a sub-dictionary</span>
<span class="sd">            with keys `template` and `values`, where `values` is a dictionary of variable value updates for the given</span>
<span class="sd">            template.</span>
<span class="sd">        connectivity</span>
<span class="sd">            Optional `list`, `tuple` or `pandas.DataFrame&#39; with connectivity information to create edges between the</span>
<span class="sd">            given circuits. If `list` or `tuple`, then each item must be formatted the same way as `edges` in</span>
<span class="sd">            `add_edges_from`: (&#39;circuit/source_node/op/var&#39;, &#39;circuit/target_node/op/var&#39;, edge_template, variables).</span>
<span class="sd">            If given as a `DataFrame`, keys (indices and column names) must refer to sources and targets, respectively,</span>
<span class="sd">            as column name/index (string of form &#39;circuit/node/op/var&#39;) and items may then be edge templates and</span>
<span class="sd">            associated variables.</span>
<span class="sd">            Empty cells in the DataFrame should be filled with something &#39;falsy&#39; (as in evaluates to `False` in Python).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        circuit</span>
<span class="sd">            instance of `CircuitIR`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ToDo: Rewrite doc to account for assumption, that only CircuitIR instances are allowed</span>

        <span class="n">circuit</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="p">{},</span> <span class="n">edges</span><span class="o">=</span><span class="p">[])</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">circ</span> <span class="ow">in</span> <span class="n">circuits</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">circ</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">connectivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">connectivity</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">connectivity</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">connectivity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">key</span><span class="p">,</span> <span class="n">conn_info</span> <span class="o">=</span> <span class="n">connectivity</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">conn_info</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                            <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                                <span class="n">snode</span><span class="p">,</span> <span class="n">tnode</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                                <span class="n">svar</span><span class="p">,</span> <span class="n">tvar</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
                                <span class="n">snode</span><span class="p">,</span> <span class="n">tnode</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">snode</span><span class="p">),</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tnode</span><span class="p">)</span>
                                <span class="n">svar</span><span class="p">,</span> <span class="n">tvar</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">svar</span><span class="p">),</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tvar</span><span class="p">)</span>
                                <span class="n">content</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">content</span><span class="p">}</span> <span class="k">if</span> <span class="n">content</span> <span class="k">else</span> <span class="p">{}</span>
                                <span class="k">for</span> <span class="n">key_tmp</span><span class="p">,</span> <span class="n">conn_info_tmp</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                    <span class="n">content_tmp</span> <span class="o">=</span> <span class="n">conn_info_tmp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">]</span>
                                    <span class="k">if</span> <span class="n">content_tmp</span><span class="p">:</span>
                                        <span class="n">content</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key_tmp</span><span class="p">:</span> <span class="n">content_tmp</span><span class="p">})</span>
                                <span class="n">content</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;source_var&#39;</span><span class="p">:</span> <span class="n">svar</span><span class="p">,</span> <span class="s1">&#39;target_var&#39;</span><span class="p">:</span> <span class="n">tvar</span><span class="p">})</span>
                                <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">content</span> <span class="ow">and</span> <span class="n">content</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]:</span>
                                    <span class="n">circuit</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">snode</span><span class="p">,</span> <span class="n">tnode</span><span class="p">,</span> <span class="n">edge_ir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">identify_relations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">content</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                            <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                                <span class="k">if</span> <span class="n">content</span><span class="p">:</span>  <span class="c1"># assumes, empty entries evaluate to `False`</span>
                                    <span class="n">snode</span><span class="p">,</span> <span class="n">tnode</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                                    <span class="n">svar</span><span class="p">,</span> <span class="n">tvar</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
                                    <span class="n">snode</span><span class="p">,</span> <span class="n">tnode</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">snode</span><span class="p">),</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tnode</span><span class="p">)</span>
                                    <span class="n">svar</span><span class="p">,</span> <span class="n">tvar</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">svar</span><span class="p">),</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tvar</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="s2">&quot;float&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">content</span><span class="p">)):</span>
                                        <span class="n">content</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">content</span><span class="p">,</span> <span class="s1">&#39;delay&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
                                    <span class="n">content</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;source_var&#39;</span><span class="p">:</span> <span class="n">svar</span><span class="p">,</span> <span class="s1">&#39;target_var&#39;</span><span class="p">:</span> <span class="n">tvar</span><span class="p">})</span>
                                    <span class="n">circuit</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">snode</span><span class="p">,</span> <span class="n">tnode</span><span class="p">,</span> <span class="n">edge_ir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">identify_relations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">content</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Invalid data type of variable `connectivity` (type: {type(connectivity)}).&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">circuit</span></div>

<div class="viewcode-block" id="CircuitIR.add_circuit"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.add_circuit">[docs]</a>    <span class="k">def</span> <span class="nf">add_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">circuit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a single circuit (with its own nodes and edges) to this circuit (like a subgraph in a graph).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label</span>
<span class="sd">            Assigned name of the circuit. If this name is already in use, the label will be renamed in the form</span>
<span class="sd">            `label.idx`.</span>
<span class="sd">        circuit</span>
<span class="sd">            Instance of `CircuitIR` or `CircuitTemplate` or a dictionary, where the key &#39;template&#39; refers to a</span>
<span class="sd">            `CircuitTemplate` instance and &#39;values&#39; refers to updates that should be applied to the template.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ToDo: disallow usage of templates here</span>

        <span class="c1"># parse data type of circuit</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">circuit</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">[</span><span class="s2">&quot;template&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">circuit</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">])</span>  <span class="c1"># type: CircuitIR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># if it is a template, apply it</span>
                <span class="n">circuit</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">apply</span><span class="p">()</span>  <span class="c1"># type: CircuitIR</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># assume circuit already is a circuitIR or similarly structured construct</span>
                <span class="k">pass</span>

        <span class="c1"># check if given circuit label already exists in this circuit</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Circuit label </span><span class="si">{label}</span><span class="s2"> already exists in this circuit. Please specify a unique &quot;</span>
                                   <span class="n">f</span><span class="s2">&quot;circuit label.&quot;</span><span class="p">)</span>
            <span class="c1"># may change to a rule to rename circuits (like circuit.0, circuit.1, circuit.2...) with label map and</span>
            <span class="c1"># counter</span>

        <span class="c1"># add circuit nodes, node by node, appending circuit label to node name</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{label}</span><span class="s2">/</span><span class="si">{name}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># add circuit reference to sub_circuits set. Needs to be done before adding edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">sub_circuits</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{label}</span><span class="s2">/</span><span class="si">{sc}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># add sub circuit label map items to local label map</span>
        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">label_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{label}</span><span class="s2">/</span><span class="si">{old}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{label}</span><span class="s2">/</span><span class="si">{new}</span><span class="s2">&quot;</span>

        <span class="c1"># add edges</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># source_var = data.pop(&quot;source_var&quot;)</span>
            <span class="c1"># target_var = data.pop(&quot;target_var&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{label}</span><span class="s2">/</span><span class="si">{source}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{label}</span><span class="s2">/</span><span class="si">{target}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">identify_relations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.from_yaml"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.from_yaml">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_yaml</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyrates.frontend</span> <span class="k">import</span> <span class="n">circuit_from_yaml</span>
        <span class="k">return</span> <span class="n">circuit_from_yaml</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.optimize_graph_in_place"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.optimize_graph_in_place">[docs]</a>    <span class="k">def</span> <span class="nf">optimize_graph_in_place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_node_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restructures network graph to collapse nodes and edges that share the same operator graphs. Variable values</span>
<span class="sd">        get an additional vector dimension. References to the respective index is saved in the internal `label_map`.&quot;&quot;&quot;</span>

        <span class="n">old_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_nodes_in_place</span><span class="p">(</span><span class="n">max_node_idx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_edges_in_place</span><span class="p">(</span><span class="n">max_node_idx</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">old_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vectorize</span><span class="p">:</span>

            <span class="c1"># go through new nodes</span>
            <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_edges</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

        <span class="c1"># go through nodes and create mapping for their inputs</span>
        <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>

            <span class="n">node_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">node_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_edges</span><span class="p">(</span><span class="n">node_inputs</span><span class="p">,</span> <span class="s1">&#39;target_var&#39;</span><span class="p">)</span>

            <span class="c1"># loop over input variables of node</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">in_var</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_inputs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

                <span class="c1"># extract delay info from input variable connections</span>
                <span class="n">n_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
                <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">in_var</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">delays</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;target_idx&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                            <span class="n">d_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">d_tmp</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">delays</span> <span class="o">+=</span> <span class="n">d</span>

                <span class="n">max_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span>

                <span class="c1"># set delays to None of max_delay is 0</span>
                <span class="k">if</span> <span class="n">max_delay</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># loop over different input sources</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">max_delay</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                        <span class="c1"># add synaptic buffer to the input variable</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge_buffer</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                                              <span class="n">buffer_length</span><span class="o">=</span><span class="n">max_delay</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                    <span class="k">elif</span> <span class="n">n_inputs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                        <span class="c1"># add synaptic input collector to the input variable</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge_input_collector</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_vectorize_nodes_in_place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_node_idx</span><span class="p">):</span>

        <span class="c1"># 1: collapse all nodes that use the same operator graph into one node</span>
        <span class="c1">######################################################################</span>

        <span class="n">node_op_graph_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># maps each unique op_graph to a collapsed node</span>
        <span class="c1"># node_counter = 1  # counts different unique types of nodes</span>
        <span class="n">name_idx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this is a safeguard to prevent overlap of newly created node names with previous nodes</span>

        <span class="c1"># collect all node data, because networkx&#39; node views update when the graph is changed.</span>

        <span class="n">old_nodes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node_key</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">node_key</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">node_key</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">old_nodes</span><span class="p">:</span>
            <span class="n">op_graph</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">op_graph</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># get reference to a previously created node</span>
                <span class="n">new_name</span><span class="p">,</span> <span class="n">collapsed_node</span> <span class="o">=</span> <span class="n">node_op_graph_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span>

                <span class="c1"># extend vectorized node by this node</span>
                <span class="n">collapsed_node</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># refer node key to new node and respective list index of its values</span>
                <span class="c1"># format: (nodeX, Z) with X = node index and Z = list index for values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">collapsed_node</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># if it does not exist, create a new one and save its reference in the map</span>
                <span class="n">collapsed_node</span> <span class="o">=</span> <span class="n">VectorizedNodeIR</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># create unique name and add node to local graph</span>
                <span class="k">while</span> <span class="n">name_idx</span> <span class="o">&lt;=</span> <span class="n">max_node_idx</span><span class="p">:</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;vector_node</span><span class="si">{name_idx}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                        <span class="n">name_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span>
                        <span class="s2">&quot;Too many nodes with generic name &#39;node</span><span class="si">{counter}</span><span class="s2">&#39; exist. Aborting vectorization.&quot;</span>
                        <span class="s2">&quot;Consider not using this naming scheme for your own nodes as it is used for &quot;</span>
                        <span class="s2">&quot;vectorization. This problem will also occur, when more unique operator graphs &quot;</span>
                        <span class="s2">&quot;exist than the maximum number of iterations allows (default: 100k). You can &quot;</span>
                        <span class="s2">&quot;increase this number by setting `max_node_idx` to a larger number.&quot;</span><span class="p">)</span>

                <span class="c1"># add new node directly to node graph, bypassing external interface</span>
                <span class="c1"># this is the &quot;in_place&quot; way to do this. Otherwise we would create an entirely new CircuitIR instance</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">collapsed_node</span><span class="p">)</span>
                <span class="n">node_op_graph_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">collapsed_node</span><span class="p">)</span>

                <span class="c1"># now save the reference to the new node name with index number to label_map</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># TODO: decide, whether reference collecting for operator_graphs in `_reference_map` is actually necessary</span>
            <span class="c1">#   and if we thus need to remove these reference again after vectorization.</span>

        <span class="k">return</span> <span class="n">old_nodes</span>

    <span class="k">def</span> <span class="nf">_vectorize_edges_in_place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_node_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_node_idx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 2: move all operators from edges to respective coupling nodes and reference labels accordingly</span>
        <span class="c1">################################################################################################</span>

        <span class="c1"># we shall assume that there is no overlap between operator_graphs in edges and nodes that is supposed to be</span>
        <span class="c1"># accounted for in vectorization.</span>

        <span class="n">node_op_graph_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># maps each unique op_graph to a collapsed node</span>
        <span class="c1"># node_counter = 1  # counts different unique types of nodes</span>
        <span class="n">node_sizes</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># counts current size of vectorized nodes</span>
        <span class="n">name_idx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this is a safeguard to prevent overlap of newly created node names with previous nodes</span>

        <span class="c1"># collect all node data, because networkx&#39; node views update when the graph is changed.</span>

        <span class="n">old_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge_key</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">old_edges</span><span class="p">:</span>
            <span class="n">specifier</span> <span class="o">=</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge_key</span><span class="p">)</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delay&quot;</span><span class="p">]</span>
            <span class="n">edge_ir</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;edge_ir&quot;</span><span class="p">]</span>
            <span class="n">source_var</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;source_var&quot;</span><span class="p">]</span>
            <span class="n">target_var</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;target_var&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">edge_ir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if the edge is empty, just add one with remapped names</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">source_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
                <span class="n">target</span><span class="p">,</span> <span class="n">target_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

                <span class="c1"># add edge from source to the new node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
                                    <span class="n">source_var</span><span class="o">=</span><span class="n">source_var</span><span class="p">,</span> <span class="n">source_idx</span><span class="o">=</span><span class="p">[</span><span class="n">source_idx</span><span class="p">],</span>
                                    <span class="n">target_var</span><span class="o">=</span><span class="n">target_var</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span>
                                    <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay</span>
                                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">op_graph</span> <span class="o">=</span> <span class="n">edge_ir</span><span class="o">.</span><span class="n">op_graph</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># get reference to a previously created node</span>
                    <span class="n">new_name</span><span class="p">,</span> <span class="n">collapsed_node</span> <span class="o">=</span> <span class="n">node_op_graph_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span>
                    <span class="c1"># add values to respective lists in collapsed node</span>
                    <span class="n">collapsed_node</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">edge_ir</span><span class="p">)</span>
                    <span class="c1"># for op_key, value_dict in edge_ir.values.items():</span>
                    <span class="c1">#     for var_key, value in value_dict.items():</span>
                    <span class="c1">#         collapsed_node.extend([f&quot;{op_key}/{var_key}&quot;][&quot;value&quot;].append(value)</span>

                    <span class="c1"># note current index of node</span>
                    <span class="n">coupling_vec_idx</span> <span class="o">=</span> <span class="n">node_sizes</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span>
                    <span class="c1"># increment op_graph size counter</span>
                    <span class="n">node_sizes</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># if it does not exist, create a new one and save its reference in the map</span>
                    <span class="n">collapsed_node</span> <span class="o">=</span> <span class="n">VectorizedNodeIR</span><span class="p">(</span><span class="n">edge_ir</span><span class="p">)</span>

                    <span class="c1"># create unique name and add node to local graph</span>
                    <span class="k">while</span> <span class="n">name_idx</span> <span class="o">&lt;=</span> <span class="n">max_node_idx</span><span class="p">:</span>
                        <span class="n">new_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;vector_coupling</span><span class="si">{name_idx}</span><span class="s2">&quot;</span>
                        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                            <span class="n">name_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span>
                            <span class="s2">&quot;Too many nodes with generic name &#39;node</span><span class="si">{counter}</span><span class="s2">&#39; exist. Aborting vectorization.&quot;</span>
                            <span class="s2">&quot;Consider not using this naming scheme for your own nodes as it is used for &quot;</span>
                            <span class="s2">&quot;vectorization. This problem will also occur, when more unique operator graphs &quot;</span>
                            <span class="s2">&quot;exist than the maximum number of iterations allows (default: 100k). You can &quot;</span>
                            <span class="s2">&quot;increase this number by setting `max_node_idx` to a larger number.&quot;</span><span class="p">)</span>

                    <span class="c1"># add new node directly to node graph, bypassing external interface</span>
                    <span class="c1"># this is the &quot;in_place&quot; way to do this. Otherwise we would create an entirely new CircuitIR instance</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">collapsed_node</span><span class="p">)</span>
                    <span class="n">node_op_graph_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">collapsed_node</span><span class="p">)</span>

                    <span class="c1"># set current index to 0</span>
                    <span class="n">coupling_vec_idx</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># and set size of this node to 1</span>
                    <span class="n">node_sizes</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># TODO: decide, whether reference collecting for operator_graphs in `_reference_map` is actually necessary</span>
                <span class="c1">#   and if we thus need to remove these reference again after vectorization.</span>

                <span class="c1"># refer node key to new node and respective list index of its values</span>
                <span class="c1"># format: &quot;nodeX[Z]&quot; with X = node index and Z = list index for values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">specifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{new_name}</span><span class="s2">[</span><span class="si">{coupling_vec_idx}</span><span class="s2">]&quot;</span>

                <span class="c1"># get new reference for source/target nodes</span>
                <span class="c1"># new references should have format &quot;vector_node{node_idx}[{vector_idx}]&quot;</span>
                <span class="c1"># the following raises an error, if the format is wrong for some reason</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">source_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
                <span class="n">target</span><span class="p">,</span> <span class="n">target_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

                <span class="c1"># add edge from source to the new node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">new_name</span><span class="p">,</span>
                                    <span class="n">source_var</span><span class="o">=</span><span class="n">source_var</span><span class="p">,</span> <span class="n">source_idx</span><span class="o">=</span><span class="p">[</span><span class="n">source_idx</span><span class="p">],</span>
                                    <span class="n">target_var</span><span class="o">=</span><span class="n">edge_ir</span><span class="o">.</span><span class="n">input_var</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="p">[</span><span class="n">coupling_vec_idx</span><span class="p">],</span>
                                    <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span>
                                    <span class="p">)</span>

                <span class="c1"># add edge from new node to target</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
                                    <span class="n">source_var</span><span class="o">=</span><span class="n">edge_ir</span><span class="o">.</span><span class="n">output_var</span><span class="p">,</span> <span class="n">source_idx</span><span class="o">=</span><span class="p">[</span><span class="n">coupling_vec_idx</span><span class="p">],</span>
                                    <span class="n">target_var</span><span class="o">=</span><span class="n">target_var</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span>
                                    <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay</span>
                                    <span class="p">)</span>

            <span class="c1"># remove old edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">specifier</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_vectorize_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combines edges in list and adds a new edge to the new net config.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source</span>
<span class="sd">            Name of the source node</span>
<span class="sd">        target</span>
<span class="sd">            Name of the target node</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># extract edges between source and target</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="c1"># extract edges that connect the same variables on source and target</span>
        <span class="c1">####################################################################</span>

        <span class="k">while</span> <span class="n">edges</span><span class="p">:</span>

            <span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># get source and target variable</span>
            <span class="n">source_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">][</span><span class="s1">&#39;source_var&#39;</span><span class="p">]</span>
            <span class="n">target_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">][</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span>

            <span class="c1"># get edges with equal source and target variables between source and target node</span>
            <span class="n">edges_tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">][</span><span class="s1">&#39;source_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">source_var</span> <span class="ow">and</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">][</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_var</span><span class="p">:</span>
                    <span class="n">edges_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

            <span class="c1"># vectorize those edges</span>
            <span class="c1">#######################</span>

            <span class="n">n_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_tmp</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_edges</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># go through edges and extract weight and delay</span>
                <span class="n">weight_col</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">delay_col</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">old_svar_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">old_tvar_idx</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">edges_tmp</span><span class="p">:</span>

                    <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                    <span class="n">delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span><span class="p">][</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span>

                    <span class="c1"># add weight, delay and variable indices to collector lists</span>
                    <span class="n">weight_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.</span> <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">weight</span><span class="p">)</span>
                    <span class="n">delay_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span> <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">delay</span><span class="p">)</span>
                    <span class="n">idx_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span><span class="p">][</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">idx_tmp</span><span class="p">:</span>
                        <span class="n">old_svar_idx</span> <span class="o">+=</span> <span class="n">idx_tmp</span>
                    <span class="n">idx_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span><span class="p">][</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">idx_tmp</span><span class="p">:</span>
                        <span class="n">old_tvar_idx</span> <span class="o">+=</span> <span class="n">idx_tmp</span>

                <span class="c1"># create new, vectorized edge</span>
                <span class="c1">#############################</span>

                <span class="c1"># extract edge</span>
                <span class="n">edge_ref</span> <span class="o">=</span> <span class="n">edges_tmp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_ref</span><span class="p">]</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge_ref</span><span class="p">))</span>

                <span class="c1"># change delay and weight attributes</span>
                <span class="n">weight_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">weight_col</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">delay_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">delay_col</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delay_col</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_col</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_svar_idx</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_tvar_idx</span>

            <span class="c1"># delete vectorized edges from list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges_tmp</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_tmp</span><span class="p">:</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>

<div class="viewcode-block" id="CircuitIR.get_node_var"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.get_node_var">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">apply_idx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key</span>
<span class="sd">        apply_idx</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># extract node, op and var name</span>
        <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>

        <span class="c1"># if node refers to vectorized network version, return variable from vectorized network</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>

            <span class="c1"># get mapping from original network nodes to vectorized network nodes</span>
            <span class="c1">#####################################################################</span>

            <span class="c1"># split original node keys</span>
            <span class="n">node_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">]</span>

            <span class="c1"># remove all nodes from original node keys that are not referred to</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node_lvl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">n_popped</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">node_lvl</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">net_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_keys</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
                        <span class="k">if</span> <span class="n">net_node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node_lvl</span><span class="p">:</span>
                            <span class="n">node_keys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">n_popped</span><span class="p">)</span>
                            <span class="n">n_popped</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># collect variable indices for the remaining nodes</span>
            <span class="n">vnode_indices</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_keys</span><span class="p">:</span>
                <span class="n">node_name_orig</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">vnode_key</span><span class="p">,</span> <span class="n">vnode_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">node_name_orig</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">vnode_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vnode_indices</span><span class="p">:</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">vnode_idx</span><span class="p">],</span> <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">node_name_orig</span><span class="p">]}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vnode_idx</span><span class="p">)</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_name_orig</span><span class="p">)</span>

            <span class="c1"># apply the indices to the vectorized node variables</span>
            <span class="k">for</span> <span class="n">vnode_key</span> <span class="ow">in</span> <span class="n">vnode_indices</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">apply_idx</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{idx[0]}</span><span class="s2">:{idx[-1] + 1}&quot;</span> <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">apply_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{vnode_key}</span><span class="s2">/</span><span class="si">{op}</span><span class="s2">/</span><span class="si">{var}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span>
                                                                              <span class="n">idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{vnode_key}</span><span class="s2">/</span><span class="si">{op}</span><span class="s2">/</span><span class="si">{var}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

            <span class="k">return</span> <span class="n">vnode_indices</span></div>

<div class="viewcode-block" id="CircuitIR.run"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">simulation_time</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">outputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">sampling_step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">out_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">profile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Simulate the backend behavior over time via a tensorflow session.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simulation_time</span>
<span class="sd">            Simulation time in seconds.</span>
<span class="sd">        inputs</span>
<span class="sd">            Inputs for placeholder variables. Each key is a tuple that specifies a placeholder variable in the graph</span>
<span class="sd">            in the following format: (node_name, op_name, var_name). Each value is an array that defines the input for</span>
<span class="sd">            the placeholder variable over time (first dimension).</span>
<span class="sd">        outputs</span>
<span class="sd">            Output variables that will be returned. Each key is the desired name of an output variable and each value is</span>
<span class="sd">            a tuple that specifies a variable in the graph in the following format: (node_name, op_name, var_name).</span>
<span class="sd">        sampling_step_size</span>
<span class="sd">            Time in seconds between sampling points of the output variables.</span>
<span class="sd">        out_dir</span>
<span class="sd">            Directory in which to store outputs.</span>
<span class="sd">        verbose</span>
<span class="sd">            If true, status updates will be printed to the console.</span>
<span class="sd">        profile</span>
<span class="sd">            Can be used to extract information about graph execution time and memory load. Can be:</span>
<span class="sd">            - `t` for returning the total graph execution time.</span>
<span class="sd">            - `m` for returning the peak memory consumption during graph excecution.</span>
<span class="sd">            - `mt` or `tm` for both</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[DataFrame, Tuple[DataFrame, float, float]]</span>
<span class="sd">            First entry of the tuple contains the output variables in a pandas dataframe, the second contains the</span>
<span class="sd">            simulation time in seconds and the third the peak memory consumption. If profiling was not chosen during</span>
<span class="sd">            call of the function, only the dataframe will be returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

        <span class="c1"># prepare simulation</span>
        <span class="c1">####################</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Preparing the simulation...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">remove_layer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">remove_layer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">top_layer</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># basic simulation parameters initialization</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">simulation_time</span><span class="p">:</span>
            <span class="n">simulation_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">sim_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">simulation_time</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sampling_step_size</span><span class="p">:</span>
            <span class="n">sampling_step_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="n">sampling_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sampling_step_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>

        <span class="c1"># add output variables to the backend</span>
        <span class="c1">#####################################</span>

        <span class="n">output_col</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">output_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output_shapes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">outputs</span><span class="p">:</span>

            <span class="c1"># go through passed output names</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">outputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># extract respective output variables from the network and store their information</span>
                <span class="k">for</span> <span class="n">var_key</span><span class="p">,</span> <span class="n">var_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">var_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">var_shape</span> <span class="ow">in</span> <span class="n">output_shapes</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">output_shapes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">var_shape</span><span class="p">)</span>
                        <span class="n">output_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">])</span>
                        <span class="n">output_keys</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                        <span class="n">output_nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">output_cols</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]])</span>
                        <span class="n">output_keys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">key</span><span class="p">])</span>
                        <span class="n">output_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]])</span>
                        <span class="n">output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_shape</span><span class="p">)</span>

                <span class="c1"># parse output storage operation into backend</span>
                <span class="n">output_col</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">add_output_layer</span><span class="p">(</span><span class="n">outputs</span><span class="o">=</span><span class="n">output_cols</span><span class="p">,</span>
                                                                 <span class="n">sampling_steps</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sim_steps</span> <span class="o">/</span> <span class="n">sampling_steps</span><span class="p">),</span>
                                                                 <span class="n">out_shapes</span><span class="o">=</span><span class="n">output_shapes</span><span class="p">))</span>

        <span class="c1"># add input variables to the backend</span>
        <span class="c1">####################################</span>

        <span class="k">if</span> <span class="n">inputs</span><span class="p">:</span>

            <span class="n">input_col</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># go through passed inputs</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">in_shape</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># extract respective input variable from the network</span>
                <span class="k">for</span> <span class="n">var_key</span><span class="p">,</span> <span class="n">var_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">apply_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">var_shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">])</span>
                    <span class="n">var_idx</span> <span class="o">=</span> <span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">var_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">var_shape</span> <span class="o">==</span> <span class="n">in_shape</span><span class="p">:</span>
                        <span class="n">input_col</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">val</span><span class="p">,</span> <span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">var_idx</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">var_shape</span> <span class="o">%</span> <span class="n">in_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">input_col</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">var_shape</span><span class="p">)),</span> <span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">var_idx</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">input_col</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_steps</span><span class="p">,)</span> <span class="o">+</span> <span class="n">var_shape</span><span class="p">),</span> <span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">var_idx</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">add_input_layer</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">input_col</span><span class="p">)</span>

        <span class="c1"># run simulation</span>
        <span class="c1">################</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running the simulation...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">profile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="n">sim_steps</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">output_col</span><span class="p">,</span> <span class="n">sampling_steps</span><span class="o">=</span><span class="n">sampling_steps</span><span class="p">,</span>
                                           <span class="n">out_dir</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">profile</span><span class="o">=</span><span class="n">profile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_col</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="n">sim_steps</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">output_col</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span>
                                                         <span class="n">profile</span><span class="o">=</span><span class="n">profile</span><span class="p">,</span> <span class="n">sampling_steps</span><span class="o">=</span><span class="n">sampling_steps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">profile</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simulation_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{simulation_time}</span><span class="s2">s of backend behavior were simulated in </span><span class="si">{time}</span><span class="s2"> s given a &quot;</span>
                      <span class="n">f</span><span class="s2">&quot;simulation resolution of </span><span class="si">{self._dt}</span><span class="s2"> s.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;ComputeGraph computations finished after </span><span class="si">{time}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;finished!&#39;</span><span class="p">)</span>

        <span class="c1"># store output variables in data frame</span>
        <span class="c1">######################################</span>

        <span class="c1"># ungroup grouped output variables</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">names</span><span class="p">,</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output_keys</span><span class="p">,</span> <span class="n">output_col</span><span class="p">,</span> <span class="n">output_nodes</span><span class="p">):</span>

            <span class="n">out_group</span> <span class="o">=</span> <span class="n">output_col</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">node_keys</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)):</span>

                <span class="n">out_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">out_group</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="n">outputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_val</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_keys</span><span class="p">):</span>
                        <span class="n">out_val_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">out_val</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_val_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">outputs</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">node_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">key</span><span class="p">,)]</span> <span class="o">=</span> <span class="n">out_val_tmp</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out_val_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                                <span class="n">outputs</span><span class="p">[(</span><span class="n">node_key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">out_val_tmp</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>

        <span class="c1"># create data frame</span>
        <span class="n">out_vars</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">sim_steps</span><span class="o">/</span><span class="n">sampling_steps</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">sampling_step_size</span><span class="p">)</span>

        <span class="c1"># return results</span>
        <span class="c1">################</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out_vars</span><span class="p">,</span> <span class="n">time</span>
        <span class="k">return</span> <span class="n">out_vars</span></div>

<div class="viewcode-block" id="CircuitIR.compile"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span>
                <span class="n">vectorization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">build_in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
                <span class="n">solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;euler&#39;</span><span class="p">,</span>
                <span class="n">float_precision</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractBaseIR</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Parses IR into the backend.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

        <span class="c1"># set basic attributes</span>
        <span class="c1">######################</span>

        <span class="c1"># instantiate the backend and set the backend default_device</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyrates.backend.tensorflow_backend</span> <span class="k">import</span> <span class="n">TensorflowBackend</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">TensorflowBackend</span>
        <span class="k">elif</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyrates.backend.numpy_backend</span> <span class="k">import</span> <span class="n">NumpyBackend</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">NumpyBackend</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Invalid backend type: </span><span class="si">{backend}</span><span class="s1">. See documentation for supported backends.&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;float_default_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">float_precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="n">backend</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># set time constant of the network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">parse_dict</span><span class="p">({</span><span class="s1">&#39;dt&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">float_precision</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">}},</span>
                        <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">)[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span>

        <span class="c1"># run graph optimization and vectorization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimize_graph_in_place</span><span class="p">(</span><span class="n">vectorize</span><span class="o">=</span><span class="n">vectorization</span><span class="p">)</span>

        <span class="c1"># move edge operations to nodes</span>
        <span class="c1">###############################</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;building the compute graph...&#39;</span><span class="p">)</span>

        <span class="c1"># create equations and variables for each edge</span>
        <span class="k">for</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="c1"># extract edge information</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span>
            <span class="n">sidx</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span>
            <span class="n">tidx</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span>
            <span class="n">svar</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;source_var&#39;</span><span class="p">]</span>
            <span class="n">sop</span><span class="p">,</span> <span class="n">svar</span> <span class="o">=</span> <span class="n">svar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="n">sval</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{source_node}</span><span class="s2">/</span><span class="si">{sop}</span><span class="s2">/</span><span class="si">{svar}</span><span class="s2">&quot;</span><span class="p">]</span>

            <span class="n">tvar</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span>
            <span class="n">top</span><span class="p">,</span> <span class="n">tvar</span> <span class="o">=</span> <span class="n">tvar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="n">tval</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{target_node}</span><span class="s2">/</span><span class="si">{top}</span><span class="s2">/</span><span class="si">{tvar}</span><span class="s2">&quot;</span><span class="p">]</span>

            <span class="n">add_project</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;add_project&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">target_node_ir</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">target_node</span><span class="p">]</span>

            <span class="c1"># define target index</span>
            <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tidx</span><span class="p">:</span>
                <span class="n">tidx_tmp</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tidx</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                        <span class="n">tidx_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tidx_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">idx</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">tidx_tmp</span>
            <span class="k">elif</span> <span class="n">delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>

            <span class="c1"># create mapping equation and its arguments</span>
            <span class="n">d</span> <span class="o">=</span> <span class="s2">&quot;[target_idx]&quot;</span> <span class="k">if</span> <span class="n">tidx</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="s2">&quot;[source_idx]&quot;</span> <span class="k">if</span> <span class="n">sidx</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">assign</span> <span class="o">=</span> <span class="s1">&#39;+=&#39;</span> <span class="k">if</span> <span class="n">add_project</span> <span class="k">else</span> <span class="s1">&#39;=&#39;</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{tvar}{d}</span><span class="s2"> </span><span class="si">{assign}</span><span class="s2"> </span><span class="si">{svar}{idx}</span><span class="s2"> * weight&quot;</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">sval</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">weight</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">tidx</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                                      <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tidx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)}</span>
            <span class="k">if</span> <span class="n">sidx</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                                      <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sidx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)}</span>
            <span class="n">args</span><span class="p">[</span><span class="n">tvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">tval</span>

            <span class="c1"># add edge operator to target node</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;edge_from_</span><span class="si">{source_node}</span><span class="s1">_</span><span class="si">{edge_idx}</span><span class="s1">&#39;</span>
            <span class="n">target_node_ir</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span>
                                  <span class="n">inputs</span><span class="o">=</span><span class="p">{</span><span class="n">svar</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">sop</span><span class="p">],</span>
                                                 <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                                                 <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">source_node</span><span class="p">}},</span>
                                  <span class="n">output</span><span class="o">=</span><span class="n">tvar</span><span class="p">,</span>
                                  <span class="n">equations</span><span class="o">=</span><span class="p">[</span><span class="n">eq</span><span class="p">],</span>
                                  <span class="n">variables</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># connect edge operator to target operator</span>
            <span class="n">target_node_ir</span><span class="o">.</span><span class="n">add_op_edge</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>

            <span class="c1"># add input information to target operator</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">target_node</span><span class="p">][</span><span class="n">top</span><span class="p">][</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tvar</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">inputs</span><span class="p">[</span><span class="n">tvar</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inputs</span><span class="p">[</span><span class="n">tvar</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">op_name</span><span class="p">],</span>
                                <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="c1"># collect node and edge operators</span>
        <span class="c1">#################################</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;all/all/dt&#39;</span><span class="p">:</span> <span class="n">dt</span><span class="p">}</span>

        <span class="c1"># edge operators</span>
        <span class="n">edge_equations</span><span class="p">,</span> <span class="n">variables_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_op_layers</span><span class="p">(</span><span class="n">layers</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">op_identifier</span><span class="o">=</span><span class="s2">&quot;edge_from_&quot;</span><span class="p">)</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variables_tmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_equations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_input_layer_added</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># node operators</span>
        <span class="n">node_equations</span><span class="p">,</span> <span class="n">variables_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_op_layers</span><span class="p">(</span><span class="n">layers</span><span class="o">=</span><span class="p">[],</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">op_identifier</span><span class="o">=</span><span class="s2">&quot;edge_from_&quot;</span><span class="p">)</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variables_tmp</span><span class="p">)</span>

        <span class="c1"># bring equations into correct order</span>
        <span class="n">equations</span> <span class="o">=</span> <span class="n">sort_equations</span><span class="p">(</span><span class="n">edge_eqs</span><span class="o">=</span><span class="n">edge_equations</span><span class="p">,</span> <span class="n">node_eqs</span><span class="o">=</span><span class="n">node_equations</span><span class="p">)</span>

        <span class="c1"># parse all equations and variables into the backend</span>
        <span class="c1">####################################################</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">bottom_layer</span><span class="p">()</span>

        <span class="c1"># parse mapping</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">parse_equation_system</span><span class="p">(</span><span class="n">equations</span><span class="o">=</span><span class="n">equations</span><span class="p">,</span> <span class="n">equation_args</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">,</span>
                                          <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span>

        <span class="c1"># save parsed variables in net config</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;inputs&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span> <span class="ow">and</span> <span class="n">var</span> <span class="o">!=</span> <span class="s2">&quot;dt&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{node}</span><span class="s2">/</span><span class="si">{op}</span><span class="s2">/</span><span class="si">{var}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_collect_op_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layers</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">exclude</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">op_identifier</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        layers</span>
<span class="sd">        exclude</span>
<span class="sd">        op_identifier</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">equations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">op_graph</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">op_graph</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">op_graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># type: DiGraph</span>

            <span class="c1"># go through all operators on node and pre-process + extract equations and variables</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>

                <span class="c1"># get all operators that have no dependencies on other operators</span>
                <span class="c1"># noinspection PyTypeChecker</span>
                <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">in_degree</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">in_degree</span> <span class="k">if</span> <span class="n">in_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">layers</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exclude</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">layers</span> <span class="ow">and</span> <span class="n">exclude</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">op_identifier</span><span class="p">:</span>
                        <span class="n">ops_tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span> <span class="k">if</span> <span class="n">op_identifier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op</span><span class="p">]</span> <span class="k">if</span> <span class="n">exclude</span> <span class="k">else</span> \
                            <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span> <span class="k">if</span> <span class="n">op_identifier</span> <span class="ow">in</span> <span class="n">op</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ops_tmp</span> <span class="o">=</span> <span class="n">ops</span>
                    <span class="n">op_eqs</span><span class="p">,</span> <span class="n">op_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_ops</span><span class="p">(</span><span class="n">ops_tmp</span><span class="p">,</span> <span class="n">node_name</span><span class="o">=</span><span class="n">node_name</span><span class="p">)</span>

                    <span class="c1"># collect primary operator equations and variables</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">):</span>
                        <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_eqs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">equations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">op_eqs</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">op_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                            <span class="n">variables</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

                <span class="c1"># remove parsed operators from graph</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">equations</span><span class="p">,</span> <span class="n">variables</span>

    <span class="k">def</span> <span class="nf">_collect_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds a number of operations to the backend graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ops</span>
<span class="sd">            Names of the operators that should be parsed into the graph.</span>
<span class="sd">        node_name</span>
<span class="sd">            Name of the node that the operators belong to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Collected and updated operator equations and variables</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set up update operation collector variable</span>
        <span class="n">equations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># add operations of same hierarchical lvl to compute graph</span>
        <span class="c1">############################################################</span>

        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>

            <span class="c1"># retrieve operator and operator args</span>
            <span class="n">op_info</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{node_name}</span><span class="s2">/</span><span class="si">{op_name}</span><span class="s2">&quot;</span><span class="p">]</span>
            <span class="n">op_args</span> <span class="o">=</span> <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">]</span>
            <span class="n">op_args</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">op_info</span><span class="p">,</span> <span class="s1">&#39;collected&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">break</span>

            <span class="c1"># handle operator inputs</span>
            <span class="n">in_ops</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># go through inputs to variable</span>
                <span class="k">if</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]:</span>

                    <span class="n">in_ops_col</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">reduce_inputs</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">bool</span> <span class="k">else</span> <span class="kc">False</span>
                    <span class="n">in_node</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;node&#39;</span> <span class="ow">in</span> <span class="n">inp</span> <span class="k">else</span> <span class="n">node_name</span>

                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">in_op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]):</span>

                        <span class="c1"># collect single input to op</span>
                        <span class="n">in_var</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{in_node}</span><span class="s2">/</span><span class="si">{in_op}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">in_val</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{in_node}</span><span class="s2">/</span><span class="si">{in_op}</span><span class="s2">/</span><span class="si">{in_var}</span><span class="s2">&quot;</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="n">in_val</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">in_ops_col</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{in_node}</span><span class="s2">/</span><span class="si">{in_op}</span><span class="s2">/</span><span class="si">{in_var}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_val</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_ops_col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">in_ops</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_multiple_inputs</span><span class="p">(</span><span class="n">in_ops_col</span><span class="p">,</span> <span class="n">reduce_inputs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">key</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">in_ops_col</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
                        <span class="n">in_node</span><span class="p">,</span> <span class="n">in_op</span><span class="p">,</span> <span class="n">in_var</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
                        <span class="n">in_ops</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_var</span><span class="p">,</span> <span class="p">{</span><span class="n">in_var</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>

            <span class="c1"># replace input variables with input in operator equations</span>
            <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">in_ops</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;equations&#39;</span><span class="p">]):</span>
                    <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;equations&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">inp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rhs_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">op_args</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># collect operator variables and equations</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{node_name}</span><span class="s2">/</span><span class="si">{op_name}</span><span class="s2">&quot;</span>
            <span class="n">variables</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{scope}</span><span class="s2">/inputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">equations</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">eq</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;equations&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">op_args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">full_key</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{scope}</span><span class="s2">/</span><span class="si">{key}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;inputs&#39;</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{scope}</span><span class="s2">/inputs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">full_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">full_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">op_info</span><span class="p">,</span> <span class="s1">&#39;collected&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;collected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">equations</span><span class="p">,</span> <span class="n">variables</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_map_multiple_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">reduce_dim</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates mapping between multiple input variables and a single output variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs</span>
<span class="sd">            Input variables.</span>
<span class="sd">        reduce_dim</span>
<span class="sd">            If true, input variables will be summed up, if false, they will be concatenated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Summed up or concatenated input variables and the mapping to the respective input variables</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inputs_unique</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">input_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">in_op</span><span class="p">,</span> <span class="n">in_var</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">in_var</span>
            <span class="k">while</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs_unique</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">inp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="n">f</span><span class="s2">&quot;_{i - 1}&quot;</span><span class="p">:</span>
                    <span class="n">inp</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="s2">&quot;_</span><span class="si">{i}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inp</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{inp}</span><span class="s2">_</span><span class="si">{i}</span><span class="s2">&quot;</span>
            <span class="n">inputs_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
            <span class="n">input_mapping</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

        <span class="k">if</span> <span class="n">reduce_dim</span><span class="p">:</span>
            <span class="n">inputs_unique</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;sum(({&#39;,&#39;.join(inputs_unique)}), 0)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">input_mapping</span><span class="p">[</span><span class="n">inputs_unique</span><span class="p">[</span><span class="n">idx</span><span class="p">]]]</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">input_mapping</span><span class="p">[</span><span class="n">inputs_unique</span><span class="p">[</span><span class="n">idx</span><span class="p">]]]</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">inputs_unique</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;reshape(({&#39;,&#39;.join(inputs_unique)}), ({len(inputs_unique) * shape[0],}))&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inputs_unique</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;stack({&#39;,&#39;.join(inputs_unique)})&quot;</span>
        <span class="k">return</span> <span class="n">inputs_unique</span><span class="p">,</span> <span class="n">input_mapping</span>

    <span class="k">def</span> <span class="nf">_sort_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sorts edges according to the given edge attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges</span>
<span class="sd">            Collection of edges of interest.</span>
<span class="sd">        attr</span>
<span class="sd">            Name of the edge attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Key-value pairs of the different values the attribute can take on (keys) and the list of edges for which</span>
<span class="sd">            the attribute takes on that value (value).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">edges_new</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing edge index. This error message should not occur.&quot;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">edges_new</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges_new</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">edges_new</span>

    <span class="k">def</span> <span class="nf">_add_edge_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">buffer_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds a buffer variable to an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the target node of the edge.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the target operator of the edge.</span>
<span class="sd">        var</span>
<span class="sd">            Name of the target variable of the edge.</span>
<span class="sd">        idx</span>
<span class="sd">            Index of the buffer variable for that specific edge.</span>
<span class="sd">        buffer_length</span>
<span class="sd">            Length of the time-buffer that should be added to realize edge delays.</span>
<span class="sd">        edge</span>
<span class="sd">            Edge identifier (source_name, target_name, edge_idx).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{node}</span><span class="s2">/</span><span class="si">{op}</span><span class="s2">/</span><span class="si">{var}</span><span class="s2">&quot;</span><span class="p">)[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
        <span class="n">node_ir</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="c1"># create buffer variable definitions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">buffer_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">buffer_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span>
            <span class="n">buffer_shape_reset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buffer_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buffer_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">buffer_shape_reset</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">var_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                            <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">buffer_shape</span><span class="p">,</span>
                                            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span>
                                            <span class="p">},</span>
                    <span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">_reset&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                                  <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                                  <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">buffer_shape_reset</span><span class="p">,</span>
                                                  <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span>
                                                  <span class="p">}</span>
                    <span class="p">}</span>

        <span class="c1"># create buffer equations</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">eqs_op_read</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2"> = </span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">[0]&quot;</span><span class="p">]</span>
            <span class="n">eqs_op_rotate</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2"> = concat((</span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">[1:], </span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">_reset), 0)&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eqs_op_read</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2"> = </span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">[:, 0]&quot;</span><span class="p">]</span>
            <span class="n">eqs_op_rotate</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2"> = concat((</span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">[:, 1:], </span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">_reset), 1)&quot;</span><span class="p">]</span>

        <span class="c1"># add buffer operators to operator graph</span>
        <span class="n">node_ir</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_rotate_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span>
                       <span class="n">inputs</span><span class="o">=</span><span class="p">{},</span>
                       <span class="n">output</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span>
                       <span class="n">equations</span><span class="o">=</span><span class="n">eqs_op_rotate</span><span class="p">,</span>
                       <span class="n">variables</span><span class="o">=</span><span class="n">var_dict</span><span class="p">)</span>
        <span class="n">node_ir</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span>
                       <span class="n">inputs</span><span class="o">=</span><span class="p">{</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_rotate_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">],</span>
                                                       <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}},</span>
                       <span class="n">output</span><span class="o">=</span><span class="n">var</span><span class="p">,</span>
                       <span class="n">equations</span><span class="o">=</span><span class="n">eqs_op_read</span><span class="p">,</span>
                       <span class="n">variables</span><span class="o">=</span><span class="p">{})</span>

        <span class="c1"># connect operators to rest of the graph</span>
        <span class="n">node_ir</span><span class="o">.</span><span class="n">add_op_edge</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_rotate_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">node_ir</span><span class="o">.</span><span class="n">add_op_edge</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="c1"># add input information to target operator</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{node}</span><span class="s2">/</span><span class="si">{op}</span><span class="s2">&quot;</span><span class="p">)[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">inputs</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inputs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">},</span>
                           <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="c1"># update edge information</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_rotate_</span><span class="si">{idx}</span><span class="s1">/</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;add_project&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_add_edge_input_collector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds an input collector variable to an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the target node of the edge.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the target operator of the edge.</span>
<span class="sd">        var</span>
<span class="sd">            Name of the target variable of the edge.</span>
<span class="sd">        idx</span>
<span class="sd">            Index of the input collector variable on that edge.</span>
<span class="sd">        edge</span>
<span class="sd">            Edge identifier (source_name, target_name, edge_idx).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{node}</span><span class="s2">/</span><span class="si">{op}</span><span class="s2">/</span><span class="si">{var}</span><span class="s2">&quot;</span><span class="p">)[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
        <span class="n">node_ir</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="c1"># create collector equation</span>
        <span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2"> = </span><span class="si">{var}</span><span class="s2">_col_</span><span class="si">{idx}</span><span class="s2">&quot;</span><span class="p">]</span>

        <span class="c1"># create collector variable definition</span>
        <span class="n">val_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">target_shape</span><span class="p">,</span>
                    <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span>
                    <span class="p">}</span>
        <span class="n">var_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">val_dict</span><span class="p">,</span>
                    <span class="n">var</span><span class="p">:</span> <span class="n">val_dict</span><span class="p">}</span>
        <span class="c1"># added the actual output variable as well.</span>

        <span class="c1"># add collector operator to operator graph</span>
        <span class="n">node_ir</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span>
                       <span class="n">inputs</span><span class="o">=</span><span class="p">{},</span>
                       <span class="n">output</span><span class="o">=</span><span class="n">var</span><span class="p">,</span>
                       <span class="n">equations</span><span class="o">=</span><span class="n">eqs</span><span class="p">,</span>
                       <span class="n">variables</span><span class="o">=</span><span class="n">var_dict</span><span class="p">)</span>
        <span class="n">node_ir</span><span class="o">.</span><span class="n">add_op_edge</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="c1"># add input information to target operator</span>
        <span class="n">op_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{node}</span><span class="s2">/</span><span class="si">{op}</span><span class="s2">&quot;</span><span class="p">)[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">op_inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">op_inputs</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op_inputs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">},</span>
                              <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="c1"># update edge target information</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">/</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span>

<div class="viewcode-block" id="CircuitIR.clear"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.CircuitIR.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the backend graph from all operations and variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="SubCircuitView"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.SubCircuitView">[docs]</a><span class="k">class</span> <span class="nc">SubCircuitView</span><span class="p">(</span><span class="n">AbstractBaseIR</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;View on a subgraph of a circuit. In order to keep memory footprint and computational cost low, the original (top</span>
<span class="sd">    lvl) circuit is referenced locally as &#39;top_level_circuit&#39; and all subgraph-related information is computed only</span>
<span class="sd">    when needed.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">top_level_circuit</span><span class="p">:</span> <span class="n">CircuitIR</span><span class="p">,</span> <span class="n">subgraph_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span> <span class="o">=</span> <span class="n">top_level_circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subgraph_key</span> <span class="o">=</span> <span class="n">subgraph_key</span>

<div class="viewcode-block" id="SubCircuitView.getitem_from_iterator"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.SubCircuitView.getitem_from_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">getitem_from_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_iter</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.subgraph_key}</span><span class="s2">/</span><span class="si">{key}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="o">.</span><span class="n">sub_circuits</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SubCircuitView</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;node&quot;</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">induced_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the subgraph specified by `subgraph_key`.&quot;&quot;&quot;</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subgraph_key</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.__class__.__name__}</span><span class="s2"> on &#39;</span><span class="si">{self.subgraph_key}</span><span class="s2">&#39; in </span><span class="si">{self.top_level_circuit}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="sort_equations"><a class="viewcode-back" href="../../../pyrates.ir.html#pyrates.frontend.template.circuit.circuit.sort_equations">[docs]</a><span class="k">def</span> <span class="nf">sort_equations</span><span class="p">(</span><span class="n">edge_eqs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">node_eqs</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    edge_eqs</span>
<span class="sd">    node_eqs</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># clean up equations</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_eqs</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">layer</span><span class="p">:</span>
            <span class="n">edge_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_eqs</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">layer</span><span class="p">:</span>
            <span class="n">node_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># re-order node equations</span>
    <span class="n">eqs_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_popped</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node_layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_eqs</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>

        <span class="c1"># collect non-differential equations from node layer</span>
        <span class="n">layer_eqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">eq</span><span class="p">,</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">node_layer</span><span class="o">.</span><span class="n">copy</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_diff_eq</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
                <span class="n">layer_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">eq</span><span class="p">,</span> <span class="n">scope</span><span class="p">))</span>
                <span class="n">node_layer</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node_layer</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">eq</span><span class="p">,</span> <span class="n">scope</span><span class="p">)))</span>

        <span class="c1"># add non-differential equations to new equations</span>
        <span class="k">if</span> <span class="n">layer_eqs</span><span class="p">:</span>
            <span class="n">eqs_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer_eqs</span><span class="p">)</span>

        <span class="c1"># clean-up already added equations from node equations</span>
        <span class="k">if</span> <span class="n">node_layer</span><span class="p">:</span>
            <span class="n">node_eqs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">n_popped</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_layer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">n_popped</span><span class="p">)</span>
            <span class="n">n_popped</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">eqs_new</span> <span class="o">+=</span> <span class="n">edge_eqs</span>
    <span class="n">eqs_new</span> <span class="o">+=</span> <span class="n">node_eqs</span>

    <span class="k">return</span> <span class="n">eqs_new</span></div>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/PyRates_logo_color.png" alt="Logo"/>
    
    <h1 class="logo logo-name">PyRates</h1>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pyrates-neuroscience&repo=PyRates&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/pyrates-neuroscience/PyRates">
    <img
        alt="https://secure.travis-ci.org/pyrates-neuroscience/PyRates.svg?branch=master"
        src="https://secure.travis-ci.org/pyrates-neuroscience/PyRates.svg?branch=master"
    />
</a>
</p>



<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Richard Gast, Daniel Rose, Christoph Salomon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>