<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>pyrates.ir.circuit &mdash; pyrates 0.9.1-dev3 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.9.1-dev3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" >
    <link rel="search" title="Search" href="../../../search.html" >
    <link rel="top" title="pyrates 0.9.1-dev3 documentation" href="../../../index.html" >
    <link rel="up" title="Module code" href="../../index.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../../../index.html">
      <img style="border: 0;" alt="pyrates" src="../../../_static/img/pyrates_logo_large.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../../../index.html">PyRates</a></li>
	
          <li class="active"><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for pyrates.ir.circuit</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># PyRates software framework for flexible implementation of neural </span>
<span class="c1"># network model_templates and simulations. See also:</span>
<span class="c1"># https://github.com/pyrates-neuroscience/PyRates</span>
<span class="c1"># </span>
<span class="c1"># Copyright (C) 2017-2018 the original authors (Richard Gast and </span>
<span class="c1"># Daniel Rose), the Max-Planck-Institute for Human Cognitive Brain </span>
<span class="c1"># Sciences (&quot;MPI CBS&quot;) and contributors</span>
<span class="c1"># </span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1"># </span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1"># </span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;</span>
<span class="c1"># </span>
<span class="c1"># CITATION:</span>
<span class="c1"># </span>
<span class="c1"># Richard Gast and Daniel Rose et. al. in preparation</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># external imports</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">filterwarnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">networkx</span> <span class="kn">import</span> <span class="n">MultiDiGraph</span><span class="p">,</span> <span class="n">subgraph</span><span class="p">,</span> <span class="n">DiGraph</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># pyrates-internal imports</span>
<span class="kn">from</span> <span class="nn">pyrates</span> <span class="kn">import</span> <span class="n">PyRatesException</span>
<span class="kn">from</span> <span class="nn">pyrates.ir.node</span> <span class="kn">import</span> <span class="n">NodeIR</span><span class="p">,</span> <span class="n">VectorizedNodeIR</span>
<span class="kn">from</span> <span class="nn">pyrates.ir.edge</span> <span class="kn">import</span> <span class="n">EdgeIR</span>
<span class="kn">from</span> <span class="nn">pyrates.ir.abc</span> <span class="kn">import</span> <span class="n">AbstractBaseIR</span>
<span class="kn">from</span> <span class="nn">pyrates.backend.parser</span> <span class="kn">import</span> <span class="n">parse_equations</span><span class="p">,</span> <span class="n">is_diff_eq</span><span class="p">,</span> <span class="n">replace</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Daniel Rose, Richard Gast&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;Development&quot;</span>


<div class="viewcode-block" id="CircuitIR"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR">[docs]</a><span class="k">class</span> <span class="nc">CircuitIR</span><span class="p">(</span><span class="n">AbstractBaseIR</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Custom graph data structure that represents a backend of nodes and edges with associated equations</span>
<span class="sd">    and variables.&quot;&quot;&quot;</span>

    <span class="c1"># _node_label_grammar = Word(alphanums+&quot;_&quot;) + Suppress(&quot;.&quot;) + Word(nums)</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;label_map&quot;</span><span class="p">,</span> <span class="s2">&quot;graph&quot;</span><span class="p">,</span> <span class="s2">&quot;sub_circuits&quot;</span><span class="p">,</span> <span class="s2">&quot;_reference_map&quot;</span><span class="p">,</span> <span class="s2">&quot;_buffered&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;_first_run&quot;</span><span class="p">,</span> <span class="s2">&quot;_vectorized&quot;</span><span class="p">,</span> <span class="s2">&quot;_compile_info&quot;</span><span class="p">,</span> <span class="s2">&quot;_backend&quot;</span><span class="p">,</span> <span class="s2">&quot;step_size&quot;</span><span class="p">,</span> <span class="s2">&quot;solver&quot;</span><span class="p">,</span> <span class="s2">&quot;_edge_idx_counter&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;circuit&quot;</span><span class="p">,</span> <span class="n">circuits</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NodeIR</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">edges</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        label</span>
<span class="sd">            String label, could be used as fallback when subcircuiting this circuit. Currently not used, though.</span>
<span class="sd">        circuits</span>
<span class="sd">            Dictionary of sub-circuits to be added. Keys are string labels for circuits that serve as namespaces for the</span>
<span class="sd">            subcircuits. Items must be `CircuitIR` instances.</span>
<span class="sd">        nodes</span>
<span class="sd">            Dictionary of nodes of form {node_label: `NodeIR` instance}.</span>
<span class="sd">        edges</span>
<span class="sd">            List of tuples (source:str, target:str, edge_dict). `edge_dict` should contain the key &quot;edge_ir&quot; with an</span>
<span class="sd">            `EdgeIR` instance as item and optionally entries for &quot;weight&quot; and &quot;delay&quot;. `source` and `target` should be</span>
<span class="sd">            formatted as &quot;node/op/var&quot; (with optionally prepended circuits).</span>
<span class="sd">        template</span>
<span class="sd">            optional string reference to path to template that this circuit was loaded from. Leave empty, if no template</span>
<span class="sd">            was used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">MultiDiGraph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">circuits</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">temp</span> <span class="ow">in</span> <span class="n">circuits</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vectorized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compile_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffered</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_idx_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_collect_references</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_or_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Collect all references of nodes or edges to unique operator_graph instances in local `_reference_map`.</span>
<span class="sd">        References are collected as a list, because nodes and edges are (currently) not hashable.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">op_graph</span> <span class="o">=</span> <span class="n">edge_or_node</span><span class="o">.</span><span class="n">op_graph</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">op_graph</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_or_node</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge_or_node</span><span class="p">]</span>

        <span class="c1"># for key, data in edge_or_node:</span>
        <span class="c1">#     op = data[&quot;operator&quot;]</span>
        <span class="c1">#     try:</span>
        <span class="c1">#         self._reference_map[op].add(op_graph)</span>
        <span class="c1">#     except KeyError:</span>
        <span class="c1">#         self._reference_map[op] = {op_graph}</span>

<div class="viewcode-block" id="CircuitIR.add_nodes_from"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.add_nodes_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NodeIR</span><span class="p">],</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add multiple nodes to circuit. Allows networkx-style adding of nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes</span>
<span class="sd">            Dictionary with node label as key. The item is a NodeIR instance. Note that the item type is not tested</span>
<span class="sd">            here, but passing anything that does not behave like a `NodeIR` may cause problems later.</span>
<span class="sd">        attr</span>
<span class="sd">            additional keyword attributes that can be added to the node data. (default `networkx` syntax.)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get unique labels for nodes  --&gt; deprecated and removed.</span>
        <span class="c1"># for label in nodes:</span>
        <span class="c1">#     self.label_map[label] = self._get_unique_label(label)</span>

        <span class="c1"># collect references to op_graphs in nodes</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collect_references</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># assign NodeIR instances as &quot;node&quot; keys in a separate dictionary, because networkx saves node attributes into</span>
        <span class="c1"># a dictionary</span>
        <span class="c1"># reformat dictionary to tuple/generator, since networkx does not parse dictionary correctly in add_nodes_from</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;node&quot;</span><span class="p">:</span> <span class="n">node</span><span class="p">})</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.add_node"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeIR</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add single node</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label</span>
<span class="sd">            String to identify node by. Is tested for uniqueness internally, and renamed if necessary. Renamed labels</span>
<span class="sd">            are stored in the `CircuitIR` instance attribute `label_map`.</span>
<span class="sd">        node</span>
<span class="sd">            Instance of `NodeIR`. Will be added with the key &quot;node&quot; to the node dictionary.</span>
<span class="sd">        attr</span>
<span class="sd">            Additional attributes (keyword arguments) that can be added to the node data. (Default `networkx` syntax.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>

        <span class="c1"># collect references to op_graph in node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collect_references</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.add_edges_from"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.add_edges_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add multiple edges. This method explicitly assumes, that edges are given in edge_templates instead of</span>
<span class="sd">        existing instances of `EdgeIR`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges</span>
<span class="sd">            List of edges, each of shape [source/op/var, target/op/var, edge_dict]. The edge_dict must contain the</span>
<span class="sd">            keys &quot;edge_ir&quot;, and optionally &quot;weight&quot; and &quot;delay&quot;.</span>
<span class="sd">        attr</span>
<span class="sd">            Additional attributes (keyword arguments) that can be added to the edge data. (Default `networkx` syntax.)</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge_dict</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>  <span class="c1"># edge_unique_key,</span>
                          <span class="o">**</span><span class="n">edge_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.add_edges_from_matrix"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.add_edges_from_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">add_edges_from_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">template</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds all possible edges between the `source_var` and `target_var` of all passed `nodes`. `Weight` and `Delay`</span>
<span class="sd">        need to be arrays containing scalars for each of those edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_var</span>
<span class="sd">            Pointer to a variable on the source nodes (&#39;op/var&#39;).</span>
<span class="sd">        target_var</span>
<span class="sd">            Pointer to a variable on the target nodes (&#39;op/var&#39;).</span>
<span class="sd">        nodes</span>
<span class="sd">            List of node names that should be connected to each other</span>
<span class="sd">        weight</span>
<span class="sd">            Optional N x N matrix with edge weights (N = number of nodes). If not passed, all edges receive a weight of</span>
<span class="sd">            1.0.</span>
<span class="sd">        delay</span>
<span class="sd">            Optional N x N matrix with edge delays (N = number of nodes). If not passed, all edges receive a delay of</span>
<span class="sd">            0.0.</span>
<span class="sd">        template</span>
<span class="sd">            Can be link to edge template that should be used for each edge.</span>
<span class="sd">        attr</span>
<span class="sd">            Additional edge attributes. Can either be N x N matrices or other scalars/objects.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># construct edge attribute dictionary from arguments</span>
        <span class="c1">####################################################</span>

        <span class="c1"># weights and delays</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">edge_attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">weight</span><span class="p">,</span> <span class="s1">&#39;delay&#39;</span><span class="p">:</span> <span class="n">delay</span><span class="p">}</span>

        <span class="c1"># template</span>
        <span class="k">if</span> <span class="n">template</span><span class="p">:</span>
            <span class="n">edge_attributes</span><span class="p">[</span><span class="s1">&#39;edge_ir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">template</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="ow">is</span> <span class="n">EdgeIR</span> <span class="k">else</span> <span class="n">template</span><span class="o">.</span><span class="n">apply</span><span class="p">()</span>

        <span class="c1"># add rest of the attributes</span>
        <span class="n">edge_attributes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="c1"># construct edges list</span>
        <span class="c1">######################</span>

        <span class="c1"># find out which edge attributes have been passed as matrices</span>
        <span class="n">matrix_attributes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">edge_attributes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">matrix_attributes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_attributes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># create edge list</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">source</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>

                <span class="n">edge_attributes_tmp</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># extract edge attribute value from matrices</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">matrix_attributes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">edge_attributes_tmp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                <span class="c1"># add remaining attributes</span>
                <span class="n">edge_attributes_tmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edge_attributes</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

                <span class="c1"># add edge to list</span>
                <span class="n">source_key</span><span class="p">,</span> <span class="n">target_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">source_var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">target_var</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="k">if</span> <span class="n">edge_attributes_tmp</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">source_key</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">target_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source_key</span><span class="p">,</span> <span class="n">target_key</span><span class="p">,</span> <span class="n">edge_attributes_tmp</span><span class="p">))</span>

        <span class="c1"># add edges to network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.add_edge"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge_ir</span><span class="p">:</span> <span class="n">EdgeIR</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">spread</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source</span>
<span class="sd">        target</span>
<span class="sd">        edge_ir</span>
<span class="sd">        weight</span>
<span class="sd">        delay</span>
<span class="sd">        spread</span>
<span class="sd">        data</span>
<span class="sd">            If no template is given, `data` is assumed to conform to the format that is needed to add an edge. I.e.,</span>
<span class="sd">            `data` needs to contain fields for `weight`, `delay`, `edge_ir`, `source_var`, `target_var`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># step 1: parse and verify source and target specifiers</span>

        <span class="n">source_node</span><span class="p">,</span> <span class="n">source_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_edge_specifier</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s2">&quot;source_var&quot;</span><span class="p">)</span>

        <span class="n">target_node</span><span class="p">,</span> <span class="n">target_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_edge_specifier</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s2">&quot;target_var&quot;</span><span class="p">)</span>

        <span class="c1"># step 2: parse source variable specifier (might be single string or dictionary for multiple source variables)</span>

        <span class="c1"># ToDo: treat extra_sources properly, possibly by mapping inputs and sources at this point</span>
        <span class="n">source_vars</span><span class="p">,</span> <span class="n">extra_sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_source_vars</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">source_var</span><span class="p">,</span> <span class="n">edge_ir</span><span class="p">,</span>
                                                             <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;extra_sources&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="c1"># step 3: verify complete source/target paths (safeguard, might be unnecessary)</span>

        <span class="c1"># step 4: add edges</span>

        <span class="c1"># temporary workaround to make sure source/target variable/operator and nodes are defined properly</span>

        <span class="n">attr_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">edge_ir</span><span class="o">=</span><span class="n">edge_ir</span><span class="p">,</span>
                         <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                         <span class="n">delay</span><span class="o">=</span><span class="n">delay</span><span class="p">,</span>
                         <span class="n">spread</span><span class="o">=</span><span class="n">spread</span><span class="p">,</span>
                         <span class="n">source_var</span><span class="o">=</span><span class="n">source_vars</span><span class="p">,</span>
                         <span class="n">target_var</span><span class="o">=</span><span class="n">target_var</span><span class="p">,</span>
                         <span class="n">extra_sources</span><span class="o">=</span><span class="n">extra_sources</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># ToDo: make sure multiple source variables are understood down the road</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="o">**</span><span class="n">attr_dict</span><span class="p">)</span>

        <span class="c1"># collect references to op_graph in edge ir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collect_references</span><span class="p">(</span><span class="n">edge_ir</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_parse_edge_specifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specifier</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">var_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Parse source or target specifier for an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        specifier</span>
<span class="sd">            String that defines either a specific node or complete variable path of source or target for an edge.</span>
<span class="sd">            Format: *circuits/node/op/var</span>
<span class="sd">        data</span>
<span class="sd">            dictionary containing additional information about the edge. This function looks for a variable specifier</span>
<span class="sd">            as specified in `var_string`</span>
<span class="sd">        var_string</span>
<span class="sd">            String that points to an optional key of the `data` dictionary. Should be either &#39;source_var&#39; or</span>
<span class="sd">            &#39;target_var&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (node, var)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># step 1: try to get source and target variables from data dictionary, if not available, get them from</span>
        <span class="c1"># source/target  string</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># try to get source variable info from data dictionary</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">var_string</span><span class="p">)</span>  <span class="c1"># type: Union[str, dict]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># not found, assume variable info is contained in `source`</span>
            <span class="c1"># also means that there is only one source variable (on the main source node) to take care of</span>
            <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">specifier</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">var</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># source_var was in data, so `source` contains only info about source node</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">specifier</span>  <span class="c1"># type: str</span>

        <span class="c1"># step 2: verify node paths, rename if necessary</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verify_rename_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>  <span class="c1"># type: str</span>

        <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="n">var</span>

    <span class="k">def</span> <span class="nf">_verify_rename_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Verify that a given node specifier exists in the circuit. First tries to rename it accordings to the internal</span>
<span class="sd">        label map and then verifies the existence of the result.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            String that specifies a node in this circuit. Can either be prepended with sub-circuit labels. Format</span>
<span class="sd">            &#39;*circuit_labels/node_label&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        node</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># re-reference node labels, if necessary</span>
        <span class="c1"># this syntax yields `node` back as default if it is not in label_map</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>  <span class="c1"># type: str</span>

        <span class="c1"># check if node path is valid</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find node with path `</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">_parse_source_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">source_var</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">edge_ir</span><span class="p">,</span> <span class="n">extra_sources</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="nb">dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parse is source variable specifications. This tests, whether a single or more source variables and verifies</span>
<span class="sd">        all given paths.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_node</span>
<span class="sd">            String that specifies a single node as source of an edge.</span>
<span class="sd">        source_var</span>
<span class="sd">            Single variable specifier string or dictionary of form `{source_op/source_var: edge_op/edge_var</span>
<span class="sd">        edge_ir</span>
<span class="sd">            Instance of an EdgeIR that contains information about the internal structure of an edge.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        source_var</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># step 1: figure out, whether only one or more source variables are defined</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># try to treat source_var as dictionary</span>
            <span class="n">n_source_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_var</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># not a dictionary, so must be a string</span>
            <span class="n">n_source_vars</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># was a dictionary, treat case that it only has length 1</span>
            <span class="k">if</span> <span class="n">n_source_vars</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">source_var</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">source_var</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">n_source_vars</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">source_var</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>  <span class="c1"># should be op, var, but we do not need them here</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verify_path</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">source_var</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># verify that number of source variables matches number of input variables in edge</span>
            <span class="k">if</span> <span class="n">extra_sources</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_source_vars</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_sources</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_source_vars</span> <span class="o">!=</span> <span class="n">edge_ir</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mismatch between number of source variables (</span><span class="si">{</span><span class="n">n_source_vars</span><span class="si">}</span><span class="s2">) and &quot;</span>
                                       <span class="sa">f</span><span class="s2">&quot;inputs (</span><span class="si">{</span><span class="n">edge_ir</span><span class="o">.</span><span class="n">n_inputs</span><span class="si">}</span><span class="s2">) in an edge with source &#39;</span><span class="si">{</span><span class="n">source_node</span><span class="si">}</span><span class="s2">&#39; and source&quot;</span>
                                       <span class="sa">f</span><span class="s2">&quot;variables </span><span class="si">{</span><span class="n">source_var</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node_var</span><span class="p">,</span> <span class="n">edge_var</span> <span class="ow">in</span> <span class="n">source_var</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_verify_path</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">node_var</span><span class="p">)</span>

            <span class="c1"># ToDo: Get all input variables from all operators and properly map them at this stage?</span>
            <span class="c1">#  note: at this stage source_var is not manipulated at all</span>

        <span class="k">if</span> <span class="n">extra_sources</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge_var</span><span class="p">,</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">extra_sources</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verify_rename_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_verify_path</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="n">extra_sources</span><span class="p">[</span><span class="n">edge_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span>

        <span class="k">return</span> <span class="n">source_var</span><span class="p">,</span> <span class="n">extra_sources</span>

    <span class="k">def</span> <span class="nf">_verify_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parts</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parts</span>
<span class="sd">            One or more parts of a path string</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>

        <span class="c1"># check if path is valid</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find object with path `</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="CircuitIR.getitem_from_iterator"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.getitem_from_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">getitem_from_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_iter</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">SubCircuitView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;node&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">item</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shortcut to self.graph.nodes. See documentation of `networkx.MultiDiGraph.nodes`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shortcut to self.graph.edges. See documentation of `networkx.MultiDiGraph.edges`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span>

<div class="viewcode-block" id="CircuitIR.from_circuits"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.from_circuits">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_circuits</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">circuits</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Circuit creation method that takes multiple circuits (templates or instances of `CircuitIR`) as inputs to</span>
<span class="sd">        create one larger circuit out of these. With additional `connectivity` information, these circuit can directly</span>
<span class="sd">        be interlinked.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label</span>
<span class="sd">            Name of new circuit. Should not collide with any circuit label given in `circuits`.</span>
<span class="sd">        circuits</span>
<span class="sd">            Dictionary with unique circuit labels as keys and circuits as items. Circuits may either be instances of</span>
<span class="sd">            `CircuitTemplate` or `CircuitIR`. Alternatively, a circuit template may also be given via a sub-dictionary</span>
<span class="sd">            with keys `template` and `values`, where `values` is a dictionary of variable value updates for the given</span>
<span class="sd">            template.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        circuit</span>
<span class="sd">            instance of `CircuitIR`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ToDo: Rewrite doc to account for assumption, that only CircuitIR instances are allowed</span>

        <span class="n">circuit</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="p">{},</span> <span class="n">edges</span><span class="o">=</span><span class="p">[])</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">circ</span> <span class="ow">in</span> <span class="n">circuits</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">circ</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">circuit</span></div>

<div class="viewcode-block" id="CircuitIR.add_circuit"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.add_circuit">[docs]</a>    <span class="k">def</span> <span class="nf">add_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">circuit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a single circuit (with its own nodes and edges) to this circuit (like a subgraph in a graph).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label</span>
<span class="sd">            Assigned name of the circuit. If this name is already in use, the label will be renamed in the form</span>
<span class="sd">            `label.idx`.</span>
<span class="sd">        circuit</span>
<span class="sd">            Instance of `CircuitIR` or `CircuitTemplate` or a dictionary, where the key &#39;template&#39; refers to a</span>
<span class="sd">            `CircuitTemplate` instance and &#39;values&#39; refers to updates that should be applied to the template.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ToDo: disallow usage of templates here</span>

        <span class="c1"># parse data type of circuit</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">circuit</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">[</span><span class="s2">&quot;template&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">circuit</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">])</span>  <span class="c1"># type: CircuitIR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># if it is a template, apply it</span>
                <span class="n">circuit</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">apply</span><span class="p">()</span>  <span class="c1"># type: CircuitIR</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># assume circuit already is a circuitIR or similarly structured construct</span>
                <span class="k">pass</span>

        <span class="c1"># check if given circuit label already exists in this circuit</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Circuit label </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> already exists in this circuit. Please specify a unique &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;circuit label.&quot;</span><span class="p">)</span>
            <span class="c1"># may change to a rule to rename circuits (like circuit.0, circuit.1, circuit.2...) with label map and</span>
            <span class="c1"># counter</span>

        <span class="c1"># add circuit nodes, node by node, appending circuit label to node name</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># add circuit reference to sub_circuits set. Needs to be done before adding edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">sub_circuits</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sub_circuits</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">sc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># add sub circuit label map items to local label map</span>
        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">label_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">old</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">new</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># add edges</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># source_var = data.pop(&quot;source_var&quot;)</span>
            <span class="c1"># target_var = data.pop(&quot;target_var&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">verify_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.from_yaml"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.from_yaml">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_yaml</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyrates.frontend</span> <span class="kn">import</span> <span class="n">circuit_from_yaml</span>
        <span class="k">return</span> <span class="n">circuit_from_yaml</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.to_dict"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform this object into a dictionary.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyrates.frontend.dict</span> <span class="kn">import</span> <span class="n">from_circuit</span>
        <span class="k">return</span> <span class="n">from_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.optimize_graph_in_place"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.optimize_graph_in_place">[docs]</a>    <span class="k">def</span> <span class="nf">optimize_graph_in_place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_node_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dde_approx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restructures network graph to collapse nodes and edges that share the same operator graphs. Variable values</span>
<span class="sd">        get an additional vector dimension. References to the respective index is saved in the internal `label_map`.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting automatic optimization of the network graph:&quot;</span><span class="p">)</span>

        <span class="c1"># node vectorization</span>
        <span class="n">old_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_nodes_in_place</span><span class="p">(</span><span class="n">max_node_idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_edges_in_place</span><span class="p">(</span><span class="n">max_node_idx</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">old_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ...nodes in the network have been vectorized.&quot;</span><span class="p">)</span>

        <span class="c1"># edge vectorization</span>
        <span class="k">if</span> <span class="n">vectorize</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_edges</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ...edges in the network have been vectorized.&quot;</span><span class="p">)</span>

        <span class="c1"># go through nodes and create buffers for delayed outputs and mappings for their inputs</span>
        <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>

            <span class="n">node_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">node_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_edges</span><span class="p">(</span><span class="n">node_outputs</span><span class="p">,</span> <span class="s1">&#39;source_var&#39;</span><span class="p">)</span>
            <span class="n">node_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">node_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_edges</span><span class="p">(</span><span class="n">node_inputs</span><span class="p">,</span> <span class="s1">&#39;target_var&#39;</span><span class="p">)</span>

            <span class="c1"># loop over ouput variables of node</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">out_var</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_outputs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

                <span class="c1"># extract delay info from variable projections</span>
                <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">out_var</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">delays</span><span class="p">,</span> <span class="n">spreads</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">add_delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_delays_from_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

                <span class="c1"># add synaptic buffer to output variables with delay</span>
                <span class="k">if</span> <span class="n">add_delay</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge_buffer</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">delays</span><span class="o">=</span><span class="n">delays</span><span class="p">,</span>
                                          <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">spreads</span><span class="o">=</span><span class="n">spreads</span><span class="p">,</span>
                                          <span class="n">dde_approx</span><span class="o">=</span><span class="n">dde_approx</span><span class="p">)</span>

            <span class="c1"># loop over input variables of node</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">in_var</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_inputs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

                <span class="c1"># extract delay info from input variable connections</span>
                <span class="n">n_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
                <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">in_var</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>

                <span class="c1"># add synaptic input collector to the input variables</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">n_inputs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge_input_collector</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ...all edges have been connected to nodes.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_vectorize_nodes_in_place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_node_idx</span><span class="p">):</span>

        <span class="c1"># 1: collapse all nodes that use the same operator graph into one node</span>
        <span class="c1">######################################################################</span>

        <span class="n">node_op_graph_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># maps each unique op_graph to a collapsed node</span>
        <span class="c1"># node_counter = 1  # counts different unique types of nodes</span>
        <span class="n">name_idx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this is a safeguard to prevent overlap of newly created node names with previous nodes</span>

        <span class="c1"># collect all node data, because networkx&#39; node views update when the graph is changed.</span>

        <span class="n">old_nodes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node_key</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">node_key</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">node_key</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">old_nodes</span><span class="p">:</span>
            <span class="n">op_graph</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">op_graph</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># get reference to a previously created node</span>
                <span class="n">new_name</span><span class="p">,</span> <span class="n">collapsed_node</span> <span class="o">=</span> <span class="n">node_op_graph_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span>

                <span class="c1"># extend vectorized node by this node</span>
                <span class="n">collapsed_node</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># refer node key to new node and respective list index of its values</span>
                <span class="c1"># format: (nodeX, Z) with X = node index and Z = list index for values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">collapsed_node</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># if it does not exist, create a new one and save its reference in the map</span>
                <span class="n">collapsed_node</span> <span class="o">=</span> <span class="n">VectorizedNodeIR</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># create unique name and add node to local graph</span>
                <span class="k">while</span> <span class="n">name_idx</span> <span class="o">&lt;=</span> <span class="n">max_node_idx</span><span class="p">:</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;vector_node</span><span class="si">{</span><span class="n">name_idx</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                        <span class="n">name_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span>
                        <span class="s2">&quot;Too many nodes with generic name &#39;node</span><span class="si">{counter}</span><span class="s2">&#39; exist. Aborting vectorization.&quot;</span>
                        <span class="s2">&quot;Consider not using this naming scheme for your own nodes as it is used for &quot;</span>
                        <span class="s2">&quot;vectorization. This problem will also occur, when more unique operator graphs &quot;</span>
                        <span class="s2">&quot;exist than the maximum number of iterations allows (default: 100k). You can &quot;</span>
                        <span class="s2">&quot;increase this number by setting `max_node_idx` to a larger number.&quot;</span><span class="p">)</span>

                <span class="c1"># add new node directly to node graph, bypassing external interface</span>
                <span class="c1"># this is the &quot;in_place&quot; way to do this. Otherwise we would create an entirely new CircuitIR instance</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">collapsed_node</span><span class="p">)</span>
                <span class="n">node_op_graph_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">collapsed_node</span><span class="p">)</span>

                <span class="c1"># now save the reference to the new node name with index number to label_map</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># TODO: decide, whether reference collecting for operator_graphs in `_reference_map` is actually necessary</span>
            <span class="c1">#   and if we thus need to remove these reference again after vectorization.</span>

        <span class="k">return</span> <span class="n">old_nodes</span>

    <span class="k">def</span> <span class="nf">_vectorize_edges_in_place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_node_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_node_idx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 2: move all operators from edges to respective coupling nodes and reference labels accordingly</span>
        <span class="c1">################################################################################################</span>

        <span class="c1"># we shall assume that there is no overlap between operator_graphs in edges and nodes that is supposed to be</span>
        <span class="c1"># accounted for in vectorization.</span>

        <span class="n">node_op_graph_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># maps each unique op_graph to a collapsed node</span>
        <span class="c1"># node_counter = 1  # counts different unique types of nodes</span>
        <span class="n">node_sizes</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># counts current size of vectorized nodes</span>
        <span class="n">name_idx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this is a safeguard to prevent overlap of newly created node names with previous nodes</span>

        <span class="c1"># collect all node data, because networkx&#39; node views update when the graph is changed.</span>

        <span class="n">old_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge_key</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">old_edges</span><span class="p">:</span>
            <span class="n">specifier</span> <span class="o">=</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge_key</span><span class="p">)</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delay&quot;</span><span class="p">]</span>
            <span class="n">spread</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;spread&quot;</span><span class="p">]</span>
            <span class="n">edge_ir</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;edge_ir&quot;</span><span class="p">]</span>
            <span class="n">source_var</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;source_var&quot;</span><span class="p">]</span>  <span class="c1"># type: Union[str, dict]</span>
            <span class="n">target_var</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;target_var&quot;</span><span class="p">]</span>
            <span class="n">extra_sources</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;extra_sources&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">edge_ir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if the edge is empty, just add one with remapped names</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">source_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
                <span class="n">target</span><span class="p">,</span> <span class="n">target_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
                <span class="c1"># make sure simple edges do have only one source variable defined</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># try to calculate length</span>
                    <span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_var</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="c1"># no dictionary --&gt; we should be fine (assume string)</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n_vars</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="s2">&quot;Too many source variables defined. Edges with no operators allow only&quot;</span>
                                               <span class="s2">&quot;one source variable to be defined.&quot;</span><span class="p">)</span>
                        <span class="c1"># could actually do this earlier</span>

                <span class="c1"># add edge from source to the new node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
                                    <span class="n">source_var</span><span class="o">=</span><span class="n">source_var</span><span class="p">,</span> <span class="n">source_idx</span><span class="o">=</span><span class="p">[</span><span class="n">source_idx</span><span class="p">],</span>
                                    <span class="n">target_var</span><span class="o">=</span><span class="n">target_var</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span>
                                    <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="n">spread</span>
                                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">op_graph</span> <span class="o">=</span> <span class="n">edge_ir</span><span class="o">.</span><span class="n">op_graph</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># get reference to a previously created node</span>
                    <span class="n">new_name</span><span class="p">,</span> <span class="n">collapsed_node</span> <span class="o">=</span> <span class="n">node_op_graph_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span>
                    <span class="c1"># add values to respective lists in collapsed node</span>
                    <span class="n">collapsed_node</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">edge_ir</span><span class="p">)</span>
                    <span class="c1"># for op_key, value_dict in edge_ir.values.items():</span>
                    <span class="c1">#     for var_key, value in value_dict.items():</span>
                    <span class="c1">#         collapsed_node.extend([f&quot;{op_key}/{var_key}&quot;][&quot;value&quot;].append(value)</span>

                    <span class="c1"># note current index of node</span>
                    <span class="n">coupling_vec_idx</span> <span class="o">=</span> <span class="n">node_sizes</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span>
                    <span class="c1"># increment op_graph size counter</span>
                    <span class="n">node_sizes</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># if it does not exist, create a new one and save its reference in the map</span>
                    <span class="n">collapsed_node</span> <span class="o">=</span> <span class="n">VectorizedNodeIR</span><span class="p">(</span><span class="n">edge_ir</span><span class="p">)</span>

                    <span class="c1"># create unique name and add node to local graph</span>
                    <span class="k">while</span> <span class="n">name_idx</span> <span class="o">&lt;=</span> <span class="n">max_node_idx</span><span class="p">:</span>
                        <span class="n">new_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;vector_coupling</span><span class="si">{</span><span class="n">name_idx</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                            <span class="n">name_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span>
                            <span class="s2">&quot;Too many nodes with generic name &#39;vector_coupling</span><span class="si">{counter}</span><span class="s2">&#39; exist. Aborting vectorization.&quot;</span>
                            <span class="s2">&quot;Consider not using this naming scheme for your own nodes as it is used for &quot;</span>
                            <span class="s2">&quot;vectorization. This problem will also occur, when more unique operator graphs &quot;</span>
                            <span class="s2">&quot;exist than the maximum number of iterations allows (default: 100k). You can &quot;</span>
                            <span class="s2">&quot;increase this number by setting `max_node_idx` to a larger number.&quot;</span><span class="p">)</span>

                    <span class="c1"># add new node directly to node graph, bypassing external interface</span>
                    <span class="c1"># this is the &quot;in_place&quot; way to do this. Otherwise we would create an entirely new CircuitIR</span>
                    <span class="c1"># instance</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">collapsed_node</span><span class="p">)</span>
                    <span class="n">node_op_graph_map</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">collapsed_node</span><span class="p">)</span>

                    <span class="c1"># set current index to 0</span>
                    <span class="n">coupling_vec_idx</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># and set size of this node to 1</span>
                    <span class="n">node_sizes</span><span class="p">[</span><span class="n">op_graph</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># refer node key to new node and respective list index of its values</span>
                <span class="c1"># format: &quot;nodeX[Z]&quot; with X = node index and Z = list index for values</span>
                <span class="c1"># self.label_map[specifier] = f&quot;{new_name}[{coupling_vec_idx}]&quot;</span>

                <span class="c1"># get new reference for source/target nodes</span>
                <span class="c1"># new references should have format &quot;vector_node{node_idx}[{vector_idx}]&quot;</span>
                <span class="c1"># the following raises an error, if the format is wrong for some reason</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">source_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
                <span class="n">target</span><span class="p">,</span> <span class="n">target_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

                <span class="n">source_vars</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_var</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="c1"># simple/legacy case: only one input present. Unclear whether this also works with multiple</span>
                    <span class="c1"># operators that use the same input variable</span>
                    <span class="n">n_vars</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">input_var</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">edge_ir</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">values</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># add edge from source to the new node</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">new_name</span><span class="p">,</span>
                                        <span class="n">source_var</span><span class="o">=</span><span class="n">source_var</span><span class="p">,</span> <span class="n">source_idx</span><span class="o">=</span><span class="p">[</span><span class="n">source_idx</span><span class="p">],</span>
                                        <span class="n">target_var</span><span class="o">=</span><span class="n">input_var</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="p">[</span><span class="n">coupling_vec_idx</span><span class="p">],</span>
                                        <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="kc">None</span>
                                        <span class="p">)</span>

                    <span class="c1"># add edge from new node to target</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
                                        <span class="n">source_var</span><span class="o">=</span><span class="n">edge_ir</span><span class="o">.</span><span class="n">output_var</span><span class="p">,</span> <span class="n">source_idx</span><span class="o">=</span><span class="p">[</span><span class="n">coupling_vec_idx</span><span class="p">],</span>
                                        <span class="n">target_var</span><span class="o">=</span><span class="n">target_var</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span>
                                        <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="n">spread</span>
                                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">in_var</span><span class="p">,</span> <span class="n">op_vars</span> <span class="ow">in</span> <span class="n">edge_ir</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                        <span class="n">input_var</span> <span class="o">=</span> <span class="n">op_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># simple solution for now: take only first reference</span>
                        <span class="c1"># need to rewrite this, if problems arise from operators in a node referencing the same</span>
                        <span class="c1"># node-wide variable</span>

                        <span class="c1"># now fetch the source variable connected to this input variable</span>
                        <span class="c1"># should fail, if there is a mismatch between assigned input variable and actual inputs</span>
                        <span class="c1"># could check for this during edge creation in the case of multiple source variables.</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">single_source</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">source_var</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">in_var</span><span class="p">))</span>
                        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">in_var</span> <span class="ow">in</span> <span class="n">extra_sources</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="k">continue</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to divide edge with multiple source variables into many &quot;</span>
                                                       <span class="sa">f</span><span class="s2">&quot;edges with single source variable, because there is a mismatch &quot;</span>
                                                       <span class="sa">f</span><span class="s2">&quot;between assigned input variables in the source definition &quot;</span>
                                                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_var</span><span class="si">}</span><span class="s2"> and inputs as defined by internal operator graph &quot;</span>
                                                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">edge_ir</span><span class="o">.</span><span class="n">inputs</span><span class="si">}</span><span class="s2">. This happened in an edge between </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> and &quot;</span>
                                                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                        <span class="c1"># add edge from source to the new node</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">new_name</span><span class="p">,</span>
                                            <span class="n">source_var</span><span class="o">=</span><span class="n">single_source</span><span class="p">,</span> <span class="n">source_idx</span><span class="o">=</span><span class="p">[</span><span class="n">source_idx</span><span class="p">],</span>
                                            <span class="n">target_var</span><span class="o">=</span><span class="n">input_var</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="p">[</span><span class="n">coupling_vec_idx</span><span class="p">],</span>
                                            <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="kc">None</span>
                                            <span class="p">)</span>

                    <span class="c1"># add edge from new node to target</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
                                        <span class="n">source_var</span><span class="o">=</span><span class="n">edge_ir</span><span class="o">.</span><span class="n">output_var</span><span class="p">,</span> <span class="n">source_idx</span><span class="o">=</span><span class="p">[</span><span class="n">coupling_vec_idx</span><span class="p">],</span>
                                        <span class="n">target_var</span><span class="o">=</span><span class="n">target_var</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="p">[</span><span class="n">target_idx</span><span class="p">],</span>
                                        <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="n">delay</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="n">spread</span>
                                        <span class="p">)</span>

                <span class="c1"># # add edge from source to the new node</span>
                <span class="c1"># self.graph.add_edge(source, new_name,</span>
                <span class="c1">#                     source_var=source_var, source_idx=[source_idx],</span>
                <span class="c1">#                     target_var=edge_ir.input_var, target_idx=[coupling_vec_idx],</span>
                <span class="c1">#                     weight=1, delay=None, spread=None</span>
                <span class="c1">#                     )</span>
                <span class="c1">#</span>
                <span class="c1"># # add edge from new node to target</span>
                <span class="c1"># self.graph.add_edge(new_name, target,</span>
                <span class="c1">#                     source_var=edge_ir.output_var, source_idx=[coupling_vec_idx],</span>
                <span class="c1">#                     target_var=target_var, target_idx=[target_idx],</span>
                <span class="c1">#                     weight=weight, delay=delay, spread=spread</span>
                <span class="c1">#                     )</span>

                <span class="c1"># in case we have additional sources that are not linked to the source node, add edges for them also</span>
                <span class="k">if</span> <span class="n">extra_sources</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">edge_var</span><span class="p">,</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">extra_sources</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">source_op</span><span class="p">,</span> <span class="n">source_var</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
                        <span class="n">source</span><span class="p">,</span> <span class="n">source_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span>
                        <span class="n">input_var</span> <span class="o">=</span> <span class="n">edge_ir</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">edge_var</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">new_name</span><span class="p">,</span>
                                            <span class="n">source_var</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">source_op</span><span class="p">,</span> <span class="n">source_var</span><span class="p">)),</span> <span class="n">source_idx</span><span class="o">=</span><span class="p">[</span><span class="n">source_idx</span><span class="p">],</span>
                                            <span class="n">target_var</span><span class="o">=</span><span class="n">input_var</span><span class="p">,</span> <span class="n">target_idx</span><span class="o">=</span><span class="p">[</span><span class="n">coupling_vec_idx</span><span class="p">],</span>
                                            <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="kc">None</span>
                                            <span class="p">)</span>

            <span class="c1"># remove old edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">specifier</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_vectorize_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combines edges in list and adds a new edge to the new net config.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source</span>
<span class="sd">            Name of the source node</span>
<span class="sd">        target</span>
<span class="sd">            Name of the target node</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># extract edges between source and target</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">target</span><span class="p">]</span>

        <span class="c1"># extract edges that connect the same variables on source and target</span>
        <span class="c1">####################################################################</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">edges</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>

            <span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">,</span> <span class="n">edge_data_tmp</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="c1"># get source and target variable</span>
            <span class="n">source_var</span> <span class="o">=</span> <span class="n">edge_data_tmp</span><span class="p">[</span><span class="s1">&#39;source_var&#39;</span><span class="p">]</span>
            <span class="n">target_var</span> <span class="o">=</span> <span class="n">edge_data_tmp</span><span class="p">[</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span>

            <span class="c1"># get edges with equal source and target variables between source and target node</span>
            <span class="n">edges_tmp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">,</span> <span class="n">edge_data_tmp</span><span class="p">)]</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">n_edges</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edges</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="s1">&#39;source_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">source_var</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_var</span><span class="p">:</span>
                    <span class="n">edges_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># vectorize those edges</span>
            <span class="c1">#######################</span>

            <span class="n">n_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_tmp</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_edges</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># go through edges and extract weight and delay</span>
                <span class="n">weight_col</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">delay_col</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">spread_col</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">old_svar_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">old_tvar_idx</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">edge_data</span> <span class="ow">in</span> <span class="n">edges_tmp</span><span class="p">:</span>

                    <span class="n">weight</span> <span class="o">=</span> <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                    <span class="n">delay</span> <span class="o">=</span> <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span>
                    <span class="n">spread</span> <span class="o">=</span> <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;spread&#39;</span><span class="p">]</span>

                    <span class="c1"># add weight, delay and variable indices to collector lists</span>
                    <span class="n">weight_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.</span> <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">weight</span><span class="p">)</span>
                    <span class="n">delay_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span> <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">delay</span><span class="p">)</span>
                    <span class="n">spread_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span> <span class="k">if</span> <span class="n">spread</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">spread</span><span class="p">)</span>
                    <span class="n">idx_tmp</span> <span class="o">=</span> <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">idx_tmp</span><span class="p">:</span>
                        <span class="n">old_svar_idx</span> <span class="o">+=</span> <span class="n">idx_tmp</span>
                    <span class="n">idx_tmp</span> <span class="o">=</span> <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">idx_tmp</span><span class="p">:</span>
                        <span class="n">old_tvar_idx</span> <span class="o">+=</span> <span class="n">idx_tmp</span>

                <span class="c1"># create new, vectorized edge</span>
                <span class="c1">#############################</span>

                <span class="c1"># extract edge</span>

                <span class="n">new_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edges_tmp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]]</span>

                <span class="c1"># change delay and weight attributes</span>
                <span class="n">weight_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">weight_col</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">delay_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">delay_col</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">spread_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">spread_col</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delay_col</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_col</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;spread&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spread_col</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_svar_idx</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_tvar_idx</span>

                <span class="c1"># delete vectorized edges from list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges_tmp</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># advance in edge list</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: Vectorization of edges between </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">source_var</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">target_var</span><span class="si">}</span><span class="s1"> &#39;</span>
                      <span class="sa">f</span><span class="s1">&#39;failed.&#39;</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

<div class="viewcode-block" id="CircuitIR.set_node_var"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.set_node_var">[docs]</a>    <span class="k">def</span> <span class="nf">set_node_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key</span>
<span class="sd">        val</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">var_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">apply_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">popitem</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">var</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">var_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;var&#39;</span><span class="p">),</span> <span class="n">var_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;idx&#39;</span><span class="p">)</span>
        <span class="n">var</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span></div>

<div class="viewcode-block" id="CircuitIR.get_node_var"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.get_node_var">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">apply_idx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;This function extracts and returns variables from nodes of the network graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key</span>
<span class="sd">            Contains the node name, operator name and variable name, separated via slash notation: &#39;node/op/var&#39;. The</span>
<span class="sd">            node name can consist of multiple slash-separated names referring to different levels of organization of the</span>
<span class="sd">            node hierarchy in the graph (e.g. &#39;circuit1/subcircuit2/node3&#39;). At each hierarchical level, either a</span>
<span class="sd">            specific node name or a reference to all nodes can be passed (e.g. &#39;circuit1/subcircuit2/all&#39; for all nodes</span>
<span class="sd">            of subcircuit2 of circuit1). Keys can refer to vectorized nodes as well as to the orginial node names.</span>
<span class="sd">        apply_idx</span>
<span class="sd">            If true, indexing will be applied to variables that need to be extracted from their vectorized versions.</span>
<span class="sd">            If false, the vectorized variable and the respective index will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Key-value pairs for each backend variable that was found to match the passed key.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># extract node, op and var name</span>
        <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>

        <span class="c1"># if node refers to vectorized network version, return variable from vectorized network</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>

            <span class="c1"># get mapping from original network nodes to vectorized network nodes</span>
            <span class="c1">#####################################################################</span>

            <span class="c1"># split original node keys</span>
            <span class="n">node_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">]</span>

            <span class="c1"># remove all nodes from original node keys that are not referred to</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node_lvl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">n_popped</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">node_lvl</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">net_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_keys</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
                        <span class="k">if</span> <span class="n">net_node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node_lvl</span><span class="p">:</span>
                            <span class="n">node_keys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">n_popped</span><span class="p">)</span>
                            <span class="n">n_popped</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># collect variable indices for the remaining nodes</span>
            <span class="n">vnode_indices</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_keys</span><span class="p">:</span>
                <span class="n">node_name_orig</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">vnode_key</span><span class="p">,</span> <span class="n">vnode_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">node_name_orig</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">vnode_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vnode_indices</span><span class="p">:</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">vnode_idx</span><span class="p">],</span> <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">node_name_orig</span><span class="p">]}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vnode_idx</span><span class="p">)</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_name_orig</span><span class="p">)</span>

            <span class="c1"># apply the indices to the vectorized node variables</span>
            <span class="k">for</span> <span class="n">vnode_key</span> <span class="ow">in</span> <span class="n">vnode_indices</span><span class="p">:</span>
                <span class="n">var_value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vnode_key</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">var_value</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;pyrates_index&#39;</span><span class="p">:</span>
                    <span class="n">idx_start</span> <span class="o">=</span> <span class="n">var_value</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">idx_l</span><span class="p">)</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">var_value</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">idx_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)]</span>
                    <span class="n">idx_tmp</span> <span class="o">=</span> <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx_tmp</span><span class="p">]</span>
                    <span class="n">var_value</span> <span class="o">=</span> <span class="n">var_value</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">apply_idx</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">apply_idx</span><span class="p">(</span><span class="n">var_value</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_value</span>
                    <span class="n">vnode_indices</span><span class="p">[</span><span class="n">vnode_key</span><span class="p">][</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

            <span class="k">return</span> <span class="n">vnode_indices</span></div>

<div class="viewcode-block" id="CircuitIR.run"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">simulation_time</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">outputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">sampling_step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;euler&#39;</span><span class="p">,</span>
            <span class="n">out_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">profile</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Simulate the backend behavior over time via a tensorflow session.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simulation_time</span>
<span class="sd">            Simulation time in seconds.</span>
<span class="sd">        step_size</span>
<span class="sd">            Simulation step size in seconds.</span>
<span class="sd">        inputs</span>
<span class="sd">            Inputs for placeholder variables. Each key is a string that specifies a node variable in the graph</span>
<span class="sd">            via the following format: &#39;node_name/op_name/var_nam&#39;. Thereby, the node name can consist of multiple node</span>
<span class="sd">            levels for hierarchical networks and either refer to a specific node name (&#39;../node_lvl_name/..&#39;) or to</span>
<span class="sd">            all nodes (&#39;../all/..&#39;) at each level. Each value is an array that defines the input for the input variable</span>
<span class="sd">            over time (first dimension).</span>
<span class="sd">        outputs</span>
<span class="sd">            Output variables that will be returned. Each key is the desired name of an output variable and each value is</span>
<span class="sd">            a string that specifies a variable in the graph in the same format as used for the input definition:</span>
<span class="sd">            &#39;node_name/op_name/var_name&#39;.</span>
<span class="sd">        sampling_step_size</span>
<span class="sd">            Time in seconds between sampling points of the output variables.</span>
<span class="sd">        solver</span>
<span class="sd">            Numerical solving scheme to use for differential equations. Currently supported ODE solving schemes:</span>
<span class="sd">            - &#39;euler&#39; for the explicit Euler method</span>
<span class="sd">            - &#39;scipy&#39; for integration via the `scipy.integrate.solve_ivp` method.</span>
<span class="sd">        out_dir</span>
<span class="sd">            Directory in which to store outputs.</span>
<span class="sd">        verbose</span>
<span class="sd">            If true, status updates will be printed to the console.</span>
<span class="sd">        profile</span>
<span class="sd">            If true, the total graph execution time will be printed and returned.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Keyword arguments that are passed on to the chosen solver.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[DataFrame, Tuple[DataFrame, float]]</span>
<span class="sd">            First entry of the tuple contains the output variables in a pandas dataframe, the second contains the</span>
<span class="sd">            simulation time in seconds. If profiling was not chosen during call of the function, only the dataframe</span>
<span class="sd">            will be returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Simulation Progress&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-------------------&quot;</span><span class="p">)</span>

        <span class="c1"># prepare simulation</span>
        <span class="c1">####################</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Preparing the simulation:&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">remove_layer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">remove_layer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">top_layer</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># basic simulation parameters initialization</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span>
        <span class="k">if</span> <span class="n">step_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Step-size not provided. Please pass the desired initial simulation step-size to `run()`.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">simulation_time</span><span class="p">:</span>
            <span class="n">simulation_time</span> <span class="o">=</span> <span class="n">step_size</span>
        <span class="n">sim_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">simulation_time</span> <span class="o">/</span> <span class="n">step_size</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># collect backend output variables</span>
        <span class="c1">##################################</span>

        <span class="n">outputs_col</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">outputs</span><span class="p">:</span>

            <span class="c1"># go through passed output names</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">outputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># extract respective output variables from the network and store their information</span>
                <span class="n">outputs_col</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">],</span> <span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]]</span>
                                    <span class="k">for</span> <span class="n">var_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">apply_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ...user-defined output variables are logged.&quot;</span><span class="p">)</span>

        <span class="c1"># collect backend input variables</span>
        <span class="c1">#################################</span>

        <span class="n">inputs_col</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">inputs</span><span class="p">:</span>

            <span class="c1"># go through passed inputs</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">in_shape</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>

                <span class="c1"># extract respective input variable from the network</span>
                <span class="k">for</span> <span class="n">var_key</span><span class="p">,</span> <span class="n">var_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">apply_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">var_shape</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="n">var_idx</span> <span class="o">=</span> <span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">var_shape</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="n">var_idx_shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">var_idx</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">var_idx_shape</span> <span class="o">==</span> <span class="n">in_shape</span><span class="p">:</span>
                        <span class="n">inputs_col</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">val</span><span class="p">,</span> <span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">var_idx</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">var_idx_shape</span> <span class="o">%</span> <span class="n">in_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">inputs_col</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">var_idx_shape</span><span class="p">)),</span> <span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">var_idx</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inputs_col</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_steps</span><span class="p">,</span> <span class="n">var_idx_shape</span><span class="p">)),</span> <span class="n">var_info</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">var_idx</span><span class="p">))</span>

        <span class="c1"># run simulation</span>
        <span class="c1">################</span>

        <span class="n">output_col</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="o">*</span><span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">simulation_time</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span> <span class="n">dts</span><span class="o">=</span><span class="n">sampling_step_size</span><span class="p">,</span>
                                                     <span class="n">out_dir</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">outputs_col</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">inputs_col</span><span class="p">,</span>
                                                     <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">profile</span><span class="o">=</span><span class="n">profile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">profile</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simulation_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">simulation_time</span><span class="si">}</span><span class="s2">s of backend behavior were simulated in </span><span class="si">{</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> s given a &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;simulation resolution of </span><span class="si">{</span><span class="n">step_size</span><span class="si">}</span><span class="s2"> s.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ComputeGraph computations finished after </span><span class="si">{</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>

        <span class="c1"># store output variables in data frame</span>
        <span class="c1">######################################</span>

        <span class="c1"># ungroup grouped output variables</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">outkey</span><span class="p">,</span> <span class="p">(</span><span class="n">out_val</span><span class="p">,</span> <span class="n">node_keys</span><span class="p">)</span> <span class="ow">in</span> <span class="n">output_col</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_keys</span><span class="p">):</span>
                <span class="n">out_val_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">out_val</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">out_val</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_val_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">outputs</span><span class="p">[(</span><span class="n">outkey</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">node_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))]</span> <span class="o">=</span> <span class="n">out_val_tmp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out_val_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">outputs</span><span class="p">[(</span><span class="n">outkey</span><span class="p">,</span> <span class="n">node_key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">out_val_tmp</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>

        <span class="c1"># create data frame</span>
        <span class="k">if</span> <span class="n">sampling_step_size</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">sampling_step_size</span> <span class="o">&lt;</span> <span class="n">step_size</span> <span class="o">*</span> <span class="mf">0.01</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">simulation_time</span> <span class="o">/</span> <span class="n">sampling_step_size</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">new_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">step_size</span><span class="p">,</span> <span class="n">simulation_time</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">outputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">new_times</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">new_times</span>
        <span class="n">out_vars</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>

        <span class="c1"># return results</span>
        <span class="c1">################</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out_vars</span><span class="p">,</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out_vars</span></div>

<div class="viewcode-block" id="CircuitIR.compile"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">vectorization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
                <span class="n">float_precision</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                <span class="n">matrix_sparseness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">solver</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">dde_approximation_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractBaseIR</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Parses IR into the backend. Returns an instance of the CircuitIR that allows for numerical simulations via</span>
<span class="sd">        the `CircuitIR.run` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectorization</span>
<span class="sd">            Defines the mode of automatic parallelization optimization that should be used. Can be True for lumping all</span>
<span class="sd">            nodes together in a vector or False for no vectorization.</span>
<span class="sd">        backend</span>
<span class="sd">            Name of the backend in which to load the compute graph. Currently supported backends:</span>
<span class="sd">            - &#39;numpy&#39;</span>
<span class="sd">            - &#39;tensorflow&#39;</span>
<span class="sd">        float_precision</span>
<span class="sd">            Default precision of float variables. This is only used for variables for which no precision was given.</span>
<span class="sd">        matrix_sparseness</span>
<span class="sd">            Only relevant if `vectorization` is True. All edges that are vectorized and do not contain discrete delays</span>
<span class="sd">            can be realized internally via inner products between an edge weight matrix and the source variables.</span>
<span class="sd">            The matrix sparseness indicated how sparse edge weight matrices are allowed to be. If the sparseness of an</span>
<span class="sd">            edge weight matrix for a given projection would be higher, no edge weight matrix will be built/used.</span>
<span class="sd">        step_size</span>
<span class="sd">            Step-size with which the network should be simulated later on. Only needs to be passed here, if the edges of</span>
<span class="sd">            the network contain delays. Will be used to discretize the delays.</span>
<span class="sd">        solver</span>
<span class="sd">        dde_approximation_order</span>
<span class="sd">            Only relevant for delayed systems. If larger than zero, all discrete delays in the system will be</span>
<span class="sd">            automatically approximated by a system of (n+1) coupled ODEs that represent a convolution with a</span>
<span class="sd">            gamma distribution centered around the original delay (n is the approximation order).</span>
<span class="sd">        verbose</span>
<span class="sd">            If true, updates about compilation process will be displayed in the terminal.</span>
<span class="sd">        in_place</span>
<span class="sd">            If true, all variable and equation attributes on operators in the graph will be overwritten, by their</span>
<span class="sd">            compiled, backend-compatible versions. If false, a deep copy of the graph will be made first.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Additional keyword arguments that will be passed on to the backend instance. For a full list of viable</span>
<span class="sd">            keyword arguments, see the documentation of the respective backend class (`numpy_backend.NumpyBackend` or</span>
<span class="sd">            tensorflow_backend.TensorflowBackend).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Compilation Progress&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------------&quot;</span><span class="p">)</span>

        <span class="c1"># set basic attributes</span>
        <span class="c1">######################</span>

        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">in_place</span> <span class="k">else</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="n">G</span><span class="o">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span>

        <span class="c1"># instantiate the backend and set the backend default_device</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyrates.backend.tensorflow_backend</span> <span class="kn">import</span> <span class="n">TensorflowBackend</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">TensorflowBackend</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;squeeze&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyrates.backend.numpy_backend</span> <span class="kn">import</span> <span class="n">NumpyBackend</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">NumpyBackend</span>
        <span class="k">elif</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;fortran&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyrates.backend.fortran_backend</span> <span class="kn">import</span> <span class="n">FortranBackend</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">FortranBackend</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;squeeze&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid backend type: </span><span class="si">{</span><span class="n">backend</span><span class="si">}</span><span class="s1">. See documentation for supported backends.&#39;</span><span class="p">)</span>
        <span class="n">squeeze_vars</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;squeeze&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">label</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;float_default_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">float_precision</span>
        <span class="n">G</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="n">backend</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># run graph optimization and vectorization</span>
        <span class="n">G</span><span class="o">.</span><span class="n">_first_run</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">G</span><span class="o">.</span><span class="n">optimize_graph_in_place</span><span class="p">(</span><span class="n">vectorize</span><span class="o">=</span><span class="n">vectorization</span><span class="p">,</span> <span class="n">dde_approx</span><span class="o">=</span><span class="n">dde_approximation_order</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># move edge operations to nodes</span>
        <span class="c1">###############################</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading the network model into the backend:&#39;</span><span class="p">)</span>

        <span class="c1"># create equations and variables for each edge</span>
        <span class="k">for</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="c1"># extract edge information</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
            <span class="n">sidx</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span>
            <span class="n">tidx</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span>
            <span class="n">svar</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;source_var&#39;</span><span class="p">]</span>
            <span class="n">sop</span><span class="p">,</span> <span class="n">svar</span> <span class="o">=</span> <span class="n">svar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="n">sval</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">sop</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">svar</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
            <span class="n">tvar</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span>
            <span class="n">top</span><span class="p">,</span> <span class="n">tvar</span> <span class="o">=</span> <span class="n">tvar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="n">tval</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">target_node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">top</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">tvar</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
            <span class="n">target_node_ir</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">target_node</span><span class="p">]</span>

            <span class="c1"># check whether edge projection can be solved by a simple inner product between a weight matrix and the</span>
            <span class="c1"># source variables</span>
            <span class="n">dot_edge</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tval</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sval</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sidx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">tval</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sval</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># check whether the weight matrix is dense enough for this edge realization to be efficient</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">matrix_sparseness</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="n">weight_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">tidx</span><span class="p">:</span>
                        <span class="n">tidx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sidx</span><span class="p">))]</span>
                    <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tidx</span><span class="p">,</span> <span class="n">sidx</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
                        <span class="n">weight_mat</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>

                    <span class="c1"># set up weights and edge projection equation</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tvar</span><span class="si">}</span><span class="s2"> = weight @ </span><span class="si">{</span><span class="n">svar</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">weight_mat</span>
                    <span class="n">dot_edge</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># set up edge projection equation and edge indices for edges that cannot be realized via a matrix product</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tidx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tval</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tval</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">tidx</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tidx</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tidx</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tval</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">tidx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="s2">&quot;[source_idx]&quot;</span> <span class="k">if</span> <span class="n">sidx</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sval</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dot_edge</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tvar</span><span class="si">}</span><span class="s2"> = target_idx @ (</span><span class="si">{</span><span class="n">svar</span><span class="si">}{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> * weight)&quot;</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tvar</span><span class="si">}</span><span class="s2">[target_idx] = </span><span class="si">{</span><span class="n">svar</span><span class="si">}{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> * weight&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tvar</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">svar</span><span class="si">}{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> * weight&quot;</span>

            <span class="c1"># add edge variables to dict</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">sval</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">weight</span><span class="p">}</span>
            <span class="n">args</span><span class="p">[</span><span class="n">tvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">tval</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">args</span><span class="p">[</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                      <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)}</span>
            <span class="k">if</span> <span class="n">idx</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                                      <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sidx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)}</span>

            <span class="c1"># add edge operator to target node</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;edge_from_</span><span class="si">{</span><span class="n">source_node</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">edge_idx</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">target_node_ir</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span>
                                  <span class="n">inputs</span><span class="o">=</span><span class="p">{</span><span class="n">svar</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">sop</span><span class="p">],</span>
                                                 <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                                                 <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">source_node</span><span class="p">,</span>
                                                 <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">svar</span><span class="p">}},</span>
                                  <span class="n">output</span><span class="o">=</span><span class="n">tvar</span><span class="p">,</span>
                                  <span class="n">equations</span><span class="o">=</span><span class="p">[</span><span class="n">eq</span><span class="p">],</span>
                                  <span class="n">variables</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># connect edge operator to target operator</span>
            <span class="n">target_node_ir</span><span class="o">.</span><span class="n">add_op_edge</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>

            <span class="c1"># add input information to target operator</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">target_node</span><span class="p">][</span><span class="n">top</span><span class="p">][</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tvar</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">inputs</span><span class="p">[</span><span class="n">tvar</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inputs</span><span class="p">[</span><span class="n">tvar</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">op_name</span><span class="p">],</span>
                                <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ...all edge operations have been translated to backend-compatible equations.&quot;</span><span class="p">)</span>

        <span class="c1"># collect node and edge operators</span>
        <span class="c1">#################################</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># edge operators</span>
        <span class="n">edge_equations</span><span class="p">,</span> <span class="n">variables_tmp</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_collect_op_layers</span><span class="p">(</span><span class="n">layers</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">op_identifier</span><span class="o">=</span><span class="s2">&quot;edge_from_&quot;</span><span class="p">)</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variables_tmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">edge_equations</span><span class="p">):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_input_layer_added</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># node operators</span>
        <span class="n">node_equations</span><span class="p">,</span> <span class="n">variables_tmp</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">_collect_op_layers</span><span class="p">(</span><span class="n">layers</span><span class="o">=</span><span class="p">[],</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">op_identifier</span><span class="o">=</span><span class="s2">&quot;edge_from_&quot;</span><span class="p">)</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variables_tmp</span><span class="p">)</span>

        <span class="c1"># bring equations into correct order</span>
        <span class="n">equations</span> <span class="o">=</span> <span class="n">sort_equations</span><span class="p">(</span><span class="n">edge_eqs</span><span class="o">=</span><span class="n">edge_equations</span><span class="p">,</span> <span class="n">node_eqs</span><span class="o">=</span><span class="n">node_equations</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ...all model equations have been collected from the network.&quot;</span><span class="p">)</span>

        <span class="c1"># parse all equations and variables into the backend</span>
        <span class="c1">####################################################</span>

        <span class="n">G</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">bottom_layer</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Parsing the model equations into a compute graph.&quot;</span><span class="p">)</span>

        <span class="c1"># parse mapping</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">parse_equations</span><span class="p">(</span><span class="n">equations</span><span class="o">=</span><span class="n">equations</span><span class="p">,</span> <span class="n">equation_args</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">_backend</span><span class="p">,</span>
                                    <span class="n">squeeze</span><span class="o">=</span><span class="n">squeeze_vars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Compilation finished!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># save parsed variables in net config</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;y&#39;</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;y_delta&#39;</span><span class="p">:</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;inputs&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">G</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">pass</span>

        <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="CircuitIR.generate_auto_def"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.generate_auto_def">[docs]</a>    <span class="k">def</span> <span class="nf">generate_auto_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dir</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates fortran files needed by auto (and pyauto) to run parameter continuaitons. The `run` method should be</span>
<span class="sd">        called at least once before calling this method to start parameter continuations from a well-defined</span>
<span class="sd">        initial state (i.e. a fixed point).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dir</span>
<span class="sd">            Build directory. If the `CircuitIR.run` method has been called previously, this should take the same value as the</span>
<span class="sd">            `build_dir` argument of `run`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Full path to the generated auto file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">,</span> <span class="s1">&#39;generate_auto_def&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">generate_auto_def</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Method not implemented for the chosen backend: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">. Please&#39;</span>
                                      <span class="sa">f</span><span class="s1">&#39;choose another backend (e.g. `fortran`) to generate an auto file of the system.&#39;</span>
                                      <span class="p">)</span></div>

<div class="viewcode-block" id="CircuitIR.to_pyauto"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.to_pyauto">[docs]</a>    <span class="k">def</span> <span class="nf">to_pyauto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dir</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">,</span> <span class="s1">&#39;to_pyauto&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">to_pyauto</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Method not implemented for the chosen backend: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">. Please&#39;</span>
                                      <span class="sa">f</span><span class="s1">&#39;choose another backend (e.g. `fortran`) to generate a pyauto instance of the &#39;</span>
                                      <span class="sa">f</span><span class="s1">&#39;system.&#39;</span>
                                      <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_collect_op_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layers</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">exclude</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">op_identifier</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        layers</span>
<span class="sd">        exclude</span>
<span class="sd">        op_identifier</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">equations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">op_graph</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">op_graph</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">op_graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># type: DiGraph</span>

            <span class="c1"># go through all operators on node and pre-process + extract equations and variables</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>

                <span class="c1"># get all operators that have no dependencies on other operators</span>
                <span class="c1"># noinspection PyTypeChecker</span>
                <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">in_degree</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">in_degree</span> <span class="k">if</span> <span class="n">in_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">layers</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exclude</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">layers</span> <span class="ow">and</span> <span class="n">exclude</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">op_identifier</span><span class="p">:</span>
                        <span class="n">ops_tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span> <span class="k">if</span> <span class="n">op_identifier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op</span><span class="p">]</span> <span class="k">if</span> <span class="n">exclude</span> <span class="k">else</span> \
                            <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span> <span class="k">if</span> <span class="n">op_identifier</span> <span class="ow">in</span> <span class="n">op</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ops_tmp</span> <span class="o">=</span> <span class="n">ops</span>
                    <span class="n">op_eqs</span><span class="p">,</span> <span class="n">op_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_ops</span><span class="p">(</span><span class="n">ops_tmp</span><span class="p">,</span> <span class="n">node_name</span><span class="o">=</span><span class="n">node_name</span><span class="p">)</span>

                    <span class="c1"># collect primary operator equations and variables</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">):</span>
                        <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_eqs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">equations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">op_eqs</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">op_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                            <span class="n">variables</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

                <span class="c1"># remove parsed operators from graph</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">equations</span><span class="p">,</span> <span class="n">variables</span>

    <span class="k">def</span> <span class="nf">_collect_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds a number of operations to the backend graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ops</span>
<span class="sd">            Names of the operators that should be parsed into the graph.</span>
<span class="sd">        node_name</span>
<span class="sd">            Name of the node that the operators belong to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Collected and updated operator equations and variables</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set up update operation collector variable</span>
        <span class="n">equations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># add operations of same hierarchical lvl to compute graph</span>
        <span class="c1">############################################################</span>

        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>

            <span class="c1"># retrieve operator and operator args</span>
            <span class="n">op_info</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">op_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
            <span class="n">op_args</span> <span class="o">=</span> <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">]</span>
            <span class="n">op_args</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">op_info</span><span class="p">,</span> <span class="s1">&#39;collected&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">break</span>

            <span class="c1"># handle operator inputs</span>
            <span class="n">in_ops</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># go through inputs to variable</span>
                <span class="k">if</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]:</span>

                    <span class="n">in_ops_col</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">reduce_inputs</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">bool</span> <span class="k">else</span> <span class="kc">False</span>
                    <span class="n">in_node</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;node&#39;</span> <span class="ow">in</span> <span class="n">inp</span> <span class="k">else</span> <span class="n">node_name</span>
                    <span class="n">in_var_tmp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">in_op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]):</span>

                        <span class="c1"># collect single input to op</span>
                        <span class="n">in_var</span> <span class="o">=</span> <span class="n">in_var_tmp</span> <span class="k">if</span> <span class="n">in_var_tmp</span> <span class="k">else</span> <span class="bp">self</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">in_node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">in_op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">in_val</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">in_node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">in_op</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">in_var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="n">in_val</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">in_ops_col</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">in_node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">in_op</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">in_var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_val</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_ops_col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">in_ops</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_multiple_inputs</span><span class="p">(</span><span class="n">in_ops_col</span><span class="p">,</span> <span class="n">reduce_inputs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">key</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">in_ops_col</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
                        <span class="n">in_node</span><span class="p">,</span> <span class="n">in_op</span><span class="p">,</span> <span class="n">in_var</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
                        <span class="n">in_ops</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_var</span><span class="p">,</span> <span class="p">{</span><span class="n">in_var</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>

            <span class="c1"># replace input variables with input in operator equations</span>
            <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">in_ops</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;equations&#39;</span><span class="p">]):</span>
                    <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;equations&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">inp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rhs_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">op_args</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># collect operator variables and equations</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">op_name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">variables</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">scope</span><span class="si">}</span><span class="s2">/inputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">equations</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">eq</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;equations&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">op_args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">full_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">scope</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;inputs&#39;</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">scope</span><span class="si">}</span><span class="s2">/inputs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">full_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">full_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">op_info</span><span class="p">,</span> <span class="s1">&#39;collected&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;collected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">equations</span><span class="p">,</span> <span class="n">variables</span>

    <span class="k">def</span> <span class="nf">_collect_delays_from_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="n">means</span><span class="p">,</span> <span class="n">stds</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;delay&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span> <span class="k">else</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;spread&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;target_idx&#39;</span><span class="p">])</span>
                <span class="n">discretize</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">discretize</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_delays</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="n">discretize</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;target_idx&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_delays</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="n">discretize</span><span class="p">)</span>
            <span class="n">means</span> <span class="o">+=</span> <span class="n">d</span>
            <span class="n">stds</span> <span class="o">+=</span> <span class="n">v</span>

        <span class="n">max_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>
        <span class="n">add_delay</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;int&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">max_delay</span><span class="p">))</span> <span class="ow">and</span> <span class="n">max_delay</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="p">(</span><span class="s2">&quot;float&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">max_delay</span><span class="p">))</span> <span class="ow">and</span> <span class="n">max_delay</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">stds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">add_delay</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;source_idx&#39;</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">means</span><span class="p">,</span> <span class="n">stds</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">add_delay</span>

    <span class="k">def</span> <span class="nf">_process_delays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;scipy&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Step-size not passed for setting up edge delays. If delays are added to any &#39;</span>
                             <span class="s1">&#39;network edge, please pass the simulation `step-size` to the `compile` &#39;</span>
                             <span class="s1">&#39;method.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_delay</span><span class="p">(</span><span class="n">d_tmp</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="n">discretize</span><span class="p">)</span> <span class="k">for</span> <span class="n">d_tmp</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span> <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="k">else</span> \
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_delay</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="n">discretize</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_delay</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="n">discretize</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_preprocess_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">discretize</span><span class="p">:</span>
            <span class="n">discretize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">!=</span> <span class="s1">&#39;scipy&#39;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">delay</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="n">discretize</span> <span class="k">else</span> <span class="n">delay</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_map_multiple_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">reduce_dim</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates mapping between multiple input variables and a single output variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs</span>
<span class="sd">            Input variables.</span>
<span class="sd">        reduce_dim</span>
<span class="sd">            If true, input variables will be summed up, if false, they will be concatenated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Summed up or concatenated input variables and the mapping to the respective input variables</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inputs_unique</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">input_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">in_op</span><span class="p">,</span> <span class="n">in_var</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">in_var</span>
            <span class="k">while</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs_unique</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">inp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span>
                    <span class="n">inp</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inp</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">inputs_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
            <span class="n">input_mapping</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

        <span class="k">if</span> <span class="n">reduce_dim</span><span class="p">:</span>
            <span class="n">inputs_unique</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;sum((</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inputs_unique</span><span class="p">)</span><span class="si">}</span><span class="s2">), 0)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">input_mapping</span><span class="p">[</span><span class="n">inputs_unique</span><span class="p">[</span><span class="n">idx</span><span class="p">]]]</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">input_mapping</span><span class="p">[</span><span class="n">inputs_unique</span><span class="p">[</span><span class="n">idx</span><span class="p">]]]</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">inputs_unique</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;reshape((</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inputs_unique</span><span class="p">)</span><span class="si">}</span><span class="s2">), (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs_unique</span><span class="p">)</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="si">}</span><span class="s2">))&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inputs_unique</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;stack(</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inputs_unique</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">return</span> <span class="n">inputs_unique</span><span class="p">,</span> <span class="n">input_mapping</span>

    <span class="k">def</span> <span class="nf">_sort_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sorts edges according to the given edge attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges</span>
<span class="sd">            Collection of edges of interest.</span>
<span class="sd">        attr</span>
<span class="sd">            Name of the edge attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Key-value pairs of the different values the attribute can take on (keys) and the list of edges for which</span>
<span class="sd">            the attribute takes on that value (value).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">edges_new</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing edge index. This error message should not occur.&quot;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">edges_new</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges_new</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">edges_new</span>

    <span class="k">def</span> <span class="nf">_add_edge_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">delays</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                         <span class="n">spreads</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dde_approx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds a buffer variable to an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the target node of the edge.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the target operator of the edge.</span>
<span class="sd">        var</span>
<span class="sd">            Name of the target variable of the edge.</span>
<span class="sd">        edges</span>
<span class="sd">            List with edge identifier tuples (source_name, target_name, edge_idx).</span>
<span class="sd">        delays</span>
<span class="sd">            edge delays.</span>
<span class="sd">        nodes</span>
<span class="sd">            Node indices for each edge delay.</span>
<span class="sd">        spreads</span>
<span class="sd">            Standard deviations of delay distributions around means given by `delays`.</span>
<span class="sd">        dde_approx</span>
<span class="sd">            Only relevant for delayed systems. If larger than zero, all discrete delays in the system will be</span>
<span class="sd">            automatically approximated by a system of (n+1) coupled ODEs that represent a convolution with a</span>
<span class="sd">            gamma distribution centered around the original delay (n is the approximation order).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">max_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span>

        <span class="c1"># extract target shape and node</span>
        <span class="n">node_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">target_shape</span> <span class="o">=</span> <span class="n">node_var</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
        <span class="n">node_ir</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="n">nodes_tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">nodes_tmp</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="n">source_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nodes_tmp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># ODE approximation to DDE</span>
        <span class="c1">##########################</span>

        <span class="k">if</span> <span class="n">dde_approx</span> <span class="ow">or</span> <span class="n">spreads</span><span class="p">:</span>

            <span class="c1"># calculate orders and rates of ODE-system approximations to delayed connections</span>
            <span class="k">if</span> <span class="n">spreads</span><span class="p">:</span>
                <span class="n">orders</span><span class="p">,</span> <span class="n">rates</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">delays</span><span class="p">,</span> <span class="n">spreads</span><span class="p">):</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">m</span> <span class="o">/</span> <span class="n">v</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="n">dde_approx</span> <span class="k">else</span> <span class="n">dde_approx</span><span class="p">)</span>
                    <span class="n">rates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orders</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span> <span class="k">if</span> <span class="n">m</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">orders</span><span class="p">,</span> <span class="n">rates</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">delays</span><span class="p">:</span>
                    <span class="n">orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dde_approx</span> <span class="k">if</span> <span class="n">m</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">rates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dde_approx</span> <span class="o">/</span> <span class="n">m</span> <span class="k">if</span> <span class="n">m</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">n_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orders</span><span class="p">)</span> <span class="o">/</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">order_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">orders</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>
            <span class="n">orders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orders</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)[</span><span class="n">order_idx</span><span class="p">]</span>
            <span class="n">orders_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orders</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">rates_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rates</span><span class="p">)[</span><span class="n">order_idx</span><span class="p">]</span>

            <span class="c1"># create ODE system equations</span>
            <span class="n">buffer_eqs</span><span class="p">,</span> <span class="n">var_dict</span><span class="p">,</span> <span class="n">final_idx</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">{},</span> <span class="p">[]</span>
            <span class="n">max_order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">orders</span><span class="p">)</span>
            <span class="n">target_check</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">orders</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="n">var_shape</span> <span class="o">=</span> <span class="n">target_shape</span>
            <span class="n">source_var</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_reshaped_for_edge&#39;</span> <span class="k">if</span> <span class="n">n_edges</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">var</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">idx_str</span><span class="p">,</span> <span class="n">idx_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_to_idx</span><span class="p">(</span><span class="n">orders_tmp</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">idx_f1</span><span class="p">,</span> <span class="n">idx_f1_str</span><span class="p">,</span> <span class="n">idx_f1_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_to_idx</span><span class="p">(</span><span class="n">orders_tmp</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">idx_f2</span><span class="p">,</span> <span class="n">idx_f2_str</span><span class="p">,</span> <span class="n">idx_f2_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bool_to_idx</span><span class="p">(</span><span class="n">orders</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">var_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_var</span><span class="p">)</span>
                <span class="n">var_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_f1_var</span><span class="p">)</span>
                <span class="n">var_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">idx_f2_var</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">or</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">target_check</span><span class="p">:</span>
                    <span class="n">var_next</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_d</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">var_prev</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_d</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">source_var</span>
                    <span class="n">rate</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;k_d</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">idx_apply</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">idx</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">rates_tmp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">idx_apply</span> <span class="k">else</span> <span class="n">rates_tmp</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">target_check</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">var_shape</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">orders_tmp</span><span class="p">)):</span>
                        <span class="n">idx_str</span><span class="p">,</span> <span class="n">idx_f1_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">var_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),)</span> <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="k">else</span> <span class="p">()</span>
                    <span class="n">buffer_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;d/dt * </span><span class="si">{</span><span class="n">var_next</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">rate</span><span class="si">}</span><span class="s2"> * (</span><span class="si">{</span><span class="n">var_prev</span><span class="si">}{</span><span class="n">idx_str</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">var_next</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="n">var_dict</span><span class="p">[</span><span class="n">var_next</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                          <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                          <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">var_shape</span><span class="p">,</span>
                                          <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">}</span>
                    <span class="n">var_dict</span><span class="p">[</span><span class="n">rate</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                      <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                      <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">rates_tmp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">idx_apply</span> <span class="k">else</span> <span class="n">rates_tmp</span><span class="p">}</span>
                    <span class="k">if</span> <span class="n">idx_apply</span><span class="p">:</span>
                        <span class="n">orders_tmp</span> <span class="o">=</span> <span class="n">orders_tmp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                        <span class="n">rates_tmp</span> <span class="o">=</span> <span class="n">rates_tmp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">orders_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="n">orders_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">orders_tmp</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                        <span class="n">rates_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">rates_tmp</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">idx_f1</span> <span class="ow">or</span> <span class="n">idx_f1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="n">idx</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">idx1</span> <span class="o">=</span> <span class="n">idx_f2_str</span>
                        <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_f2</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx_f2</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="n">idx_f2</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">idx1</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                        <span class="n">n1</span> <span class="o">=</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">final_idx</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx_str</span> <span class="k">if</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">n</span> <span class="k">else</span> <span class="n">idx_f1_str</span><span class="p">))</span>

            <span class="c1"># remove unnecessary ODEs</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buffer_eqs</span><span class="p">)</span> <span class="o">-</span> <span class="n">final_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buffer_eqs</span><span class="p">)</span>
                <span class="n">var_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_d</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">var_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;k_d</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">buffer_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># extend source variable to match shape of edge transmission variables</span>
            <span class="k">if</span> <span class="n">n_edges</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n_edges</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n_edges</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_edges</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edges</span><span class="p">):</span>
                        <span class="n">buffer_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_var</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">i</span><span class="o">*</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">] = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes_tmp</span><span class="p">):</span>
                        <span class="n">buffer_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_var</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">] = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
                <span class="n">var_dict</span><span class="p">[</span><span class="n">source_var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                        <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orders</span><span class="p">),),</span>
                                        <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>

            <span class="c1"># create buffered variable</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="ow">in</span> <span class="n">final_idx</span><span class="p">:</span>
                <span class="n">idx1</span> <span class="o">=</span> <span class="n">idx1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">idx2</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">buffer_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered</span><span class="si">{</span><span class="n">idx1</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_d</span><span class="si">{</span><span class="n">i</span><span class="si">}{</span><span class="n">idx2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">buffer_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered</span><span class="si">{</span><span class="n">idx1</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">source_var</span><span class="si">}{</span><span class="n">idx2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">var_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                           <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">delays</span><span class="p">),),</span>
                                           <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>

            <span class="c1"># re-order buffered variable if necessary</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">order_idx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">buffer_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered[</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered_idx]&quot;</span><span class="p">)</span>
                <span class="n">var_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                                   <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                                                   <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order_idx</span><span class="p">),),</span>
                                                   <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">order_idx</span><span class="p">}</span>

        <span class="c1"># discretized edge buffers</span>
        <span class="c1">##########################</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">!=</span> <span class="s1">&#39;scipy&#39;</span><span class="p">:</span>

            <span class="c1"># create buffer variable shapes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">buffer_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_delay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">buffer_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_delay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># create buffer variable definitions</span>
            <span class="n">var_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_buffer&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                          <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                          <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">buffer_shape</span><span class="p">,</span>
                                          <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">},</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_buffered&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                            <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">delays</span><span class="p">),),</span>
                                            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">},</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_delays&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                          <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                                          <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">delays</span><span class="p">},</span>
                        <span class="sa">f</span><span class="s1">&#39;source_idx&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">source_idx</span><span class="p">}}</span>

            <span class="c1"># create buffer equations</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">buffer_eqs</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer[:] = roll(</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer, 1, 0)&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer[0] = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer[</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_delays]&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">buffer_eqs</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer[:] = roll(</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer, 1, 1)&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer[:, 0] = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer[source_idx, </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_delays]&quot;</span><span class="p">]</span>

        <span class="c1"># continuous delay buffers</span>
        <span class="c1">##########################</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># create buffer variables</span>
            <span class="n">max_delay_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">max_delay</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_delay_int</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">buffer_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">buffer_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>

            <span class="c1"># create buffer variable definitions</span>
            <span class="n">var_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_buffer&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                          <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                          <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">buffer_shape</span><span class="p">,</span>
                                          <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span>
                                          <span class="p">},</span>
                        <span class="s1">&#39;times&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                  <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                  <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),),</span>
                                  <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">times</span>
                                  <span class="p">},</span>
                        <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                              <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(),</span>
                              <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.0</span>
                              <span class="p">},</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_buffered&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                            <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">delays</span><span class="p">),),</span>
                                            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">},</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_delays&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                          <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                          <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">delays</span><span class="p">},</span>
                        <span class="sa">f</span><span class="s1">&#39;source_idx&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">source_idx</span><span class="p">},</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_maxdelay&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span><span class="p">,</span>
                                            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">max_delay_int</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">},</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_idx&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;bool&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}}</span>

            <span class="c1"># create buffer equations</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">buffer_eqs</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_idx = times &gt;= (t - </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_maxdelay)&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer[</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_idx]&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;times = times[</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_idx]&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;times = append(t, times)&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer = append(</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer)&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered = interpolate_1d(times, </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer, t - </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_delays)&quot;</span>
                              <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">buffer_eqs</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_idx = times &gt;= (t - </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_maxdelay)&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer[:, </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_idx]&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;times = times[</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_idx]&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;times = append(t, times)&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer = append(</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer, 1)&quot;</span><span class="p">,</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered = interpolate_nd(times, </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffer, </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_delays, source_idx, t)&quot;</span>
                              <span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffered</span><span class="p">:</span>
                <span class="n">buffer_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">buffer_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffered</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># add buffer equations to node operator</span>
        <span class="n">op_info</span> <span class="o">=</span> <span class="n">node_ir</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>
        <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;equations&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">buffer_eqs</span>
        <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">var_dict</span><span class="p">)</span>
        <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered&quot;</span>

        <span class="c1"># update input information of node operators connected to this operator</span>
        <span class="k">for</span> <span class="n">succ</span> <span class="ow">in</span> <span class="n">node_ir</span><span class="o">.</span><span class="n">op_graph</span><span class="o">.</span><span class="n">succ</span><span class="p">[</span><span class="n">op</span><span class="p">]:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">succ</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">inputs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">op</span><span class="p">},</span>
                               <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="c1"># update edge information</span>
        <span class="n">idx_l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;source_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_buffered&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">idx_h</span> <span class="o">=</span> <span class="n">idx_l</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">idx_l</span><span class="p">,</span> <span class="n">idx_h</span><span class="p">))</span>
                <span class="n">idx_l</span> <span class="o">=</span> <span class="n">idx_h</span>

    <span class="k">def</span> <span class="nf">_bool_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">v_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">v_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">v_idx</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">v_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">v_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">v_idx_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">v_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">elif</span> <span class="n">v_idx</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">v_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;delay_idx_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_idx_counter</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">v_idx_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="n">v_dict</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">v_idx</span><span class="p">,</span> <span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_idx_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">v_idx_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">v_idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">v_idx_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="n">v_idx</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">v_idx_str</span><span class="p">,</span> <span class="n">v_dict</span>

    <span class="k">def</span> <span class="nf">_add_edge_input_collector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds an input collector variable to an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the target node of the edge.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the target operator of the edge.</span>
<span class="sd">        var</span>
<span class="sd">            Name of the target variable of the edge.</span>
<span class="sd">        idx</span>
<span class="sd">            Index of the input collector variable on that edge.</span>
<span class="sd">        edge</span>
<span class="sd">            Edge identifier (source_name, target_name, edge_idx).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
        <span class="n">node_ir</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="c1"># create collector equation</span>
        <span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_col_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>

        <span class="c1"># create collector variable definition</span>
        <span class="n">val_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">_float_def</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">,</span>
                    <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">target_shape</span><span class="p">,</span>
                    <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span>
                    <span class="p">}</span>
        <span class="n">var_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_col_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">val_dict</span><span class="p">,</span>
                    <span class="n">var</span><span class="p">:</span> <span class="n">val_dict</span><span class="p">}</span>
        <span class="c1"># added the actual output variable as well.</span>

        <span class="c1"># add collector operator to operator graph</span>
        <span class="n">node_ir</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_col_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                       <span class="n">inputs</span><span class="o">=</span><span class="p">{},</span>
                       <span class="n">output</span><span class="o">=</span><span class="n">var</span><span class="p">,</span>
                       <span class="n">equations</span><span class="o">=</span><span class="n">eqs</span><span class="p">,</span>
                       <span class="n">variables</span><span class="o">=</span><span class="n">var_dict</span><span class="p">)</span>
        <span class="n">node_ir</span><span class="o">.</span><span class="n">add_op_edge</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_col_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="c1"># add input information to target operator</span>
        <span class="n">op_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_var</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">op_inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">op_inputs</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_col_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op_inputs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_col_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">},</span>
                              <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="c1"># update edge target information</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">][</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_col_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1">_col_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span>

<div class="viewcode-block" id="CircuitIR.clear"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.CircuitIR.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the backend graph from all operations and variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="SubCircuitView"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.SubCircuitView">[docs]</a><span class="k">class</span> <span class="nc">SubCircuitView</span><span class="p">(</span><span class="n">AbstractBaseIR</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;View on a subgraph of a circuit. In order to keep memory footprint and computational cost low, the original (top</span>
<span class="sd">    lvl) circuit is referenced locally as &#39;top_level_circuit&#39; and all subgraph-related information is computed only</span>
<span class="sd">    when needed.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">top_level_circuit</span><span class="p">:</span> <span class="n">CircuitIR</span><span class="p">,</span> <span class="n">subgraph_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span> <span class="o">=</span> <span class="n">top_level_circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subgraph_key</span> <span class="o">=</span> <span class="n">subgraph_key</span>

<div class="viewcode-block" id="SubCircuitView.getitem_from_iterator"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.SubCircuitView.getitem_from_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">getitem_from_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_iter</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>

        <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">subgraph_key</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="o">.</span><span class="n">sub_circuits</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SubCircuitView</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;node&quot;</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">induced_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the subgraph specified by `subgraph_key`.&quot;&quot;&quot;</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subgraph_key</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> on &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">subgraph_key</span><span class="si">}</span><span class="s2">&#39; in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">top_level_circuit</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="sort_equations"><a class="viewcode-back" href="../../../ir.html#pyrates.ir.circuit.sort_equations">[docs]</a><span class="k">def</span> <span class="nf">sort_equations</span><span class="p">(</span><span class="n">edge_eqs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">node_eqs</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    edge_eqs</span>
<span class="sd">    node_eqs</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># clean up equations</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_eqs</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">layer</span><span class="p">:</span>
            <span class="n">edge_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_eqs</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">layer</span><span class="p">:</span>
            <span class="n">node_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># re-order node equations</span>
    <span class="n">eqs_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_popped</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node_layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_eqs</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>

        <span class="c1"># collect non-differential equations from node layer</span>
        <span class="n">layer_eqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">eq</span><span class="p">,</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">node_layer</span><span class="o">.</span><span class="n">copy</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_diff_eq</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
                <span class="n">layer_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">eq</span><span class="p">,</span> <span class="n">scope</span><span class="p">))</span>
                <span class="n">node_layer</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node_layer</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">eq</span><span class="p">,</span> <span class="n">scope</span><span class="p">)))</span>

        <span class="c1"># add non-differential equations to new equations</span>
        <span class="k">if</span> <span class="n">layer_eqs</span><span class="p">:</span>
            <span class="n">eqs_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer_eqs</span><span class="p">)</span>

        <span class="c1"># clean-up already added equations from node equations</span>
        <span class="k">if</span> <span class="n">node_layer</span><span class="p">:</span>
            <span class="n">node_eqs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">n_popped</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_layer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">n_popped</span><span class="p">)</span>
            <span class="n">n_popped</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">eqs_new</span> <span class="o">+=</span> <span class="n">edge_eqs</span>
    <span class="n">eqs_new</span> <span class="o">+=</span> <span class="n">node_eqs</span>

    <span class="k">return</span> <span class="n">eqs_new</span></div>
</pre></div>

          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/pyrates_logo.png" alt="Logo">
            </a></p>

        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2020, Richard Gast and Daniel Rose.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.1.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>