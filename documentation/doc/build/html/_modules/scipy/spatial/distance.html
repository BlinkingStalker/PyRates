

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>scipy.spatial.distance &mdash; PyRates 0.7.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/css/PyRates_logo_color.ico"/>
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../../../',
        VERSION:'0.7.1',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

    

  

  
  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>


  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="PyRates 0.7.1 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../contents.html" class="icon icon-home"> PyRates</a>
        <form class="wy-form" action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search document" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">PyRates</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="../../../contents.html">Table of Contents</a> &raquo;</li>
  <li><a href="">scipy.spatial.distance</a></li>
  <li class="wy-breadcrumbs-aside"><a href="https://docs.google.com/forms/d/1T5QGnYb_QnQoMO7T_eatq02miPTY40WVe3cgGphNAdY/viewform?entry.1952574704&entry.241692674=PyRates%3A%20_modules/scipy/spatial/distance" target="_blank">Give Doc Feedback</a>
  </li>
</ul>
<hr/>

          
  <h1>Source code for scipy.spatial.distance</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">=====================================================</span>
<span class="sd">Distance computations (:mod:`scipy.spatial.distance`)</span>
<span class="sd">=====================================================</span>

<span class="sd">.. sectionauthor:: Damian Eads</span>

<span class="sd">Function Reference</span>
<span class="sd">------------------</span>

<span class="sd">Distance matrix computation from a collection of raw observation vectors</span>
<span class="sd">stored in a rectangular array.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   pdist   -- pairwise distances between observation vectors.</span>
<span class="sd">   cdist   -- distances between two collections of observation vectors</span>
<span class="sd">   squareform -- convert distance matrix to a condensed one and vice versa</span>
<span class="sd">   directed_hausdorff -- directed Hausdorff distance between arrays</span>

<span class="sd">Predicates for checking the validity of distance matrices, both</span>
<span class="sd">condensed and redundant. Also contained in this module are functions</span>
<span class="sd">for computing the number of observations in a distance matrix.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   is_valid_dm -- checks for a valid distance matrix</span>
<span class="sd">   is_valid_y  -- checks for a valid condensed distance matrix</span>
<span class="sd">   num_obs_dm  -- # of observations in a distance matrix</span>
<span class="sd">   num_obs_y   -- # of observations in a condensed distance matrix</span>

<span class="sd">Distance functions between two numeric vectors ``u`` and ``v``. Computing</span>
<span class="sd">distances over a large collection of vectors is inefficient for these</span>
<span class="sd">functions. Use ``pdist`` for this purpose.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   braycurtis       -- the Bray-Curtis distance.</span>
<span class="sd">   canberra         -- the Canberra distance.</span>
<span class="sd">   chebyshev        -- the Chebyshev distance.</span>
<span class="sd">   cityblock        -- the Manhattan distance.</span>
<span class="sd">   correlation      -- the Correlation distance.</span>
<span class="sd">   cosine           -- the Cosine distance.</span>
<span class="sd">   euclidean        -- the Euclidean distance.</span>
<span class="sd">   jensenshannon    -- the Jensen-Shannon distance.</span>
<span class="sd">   mahalanobis      -- the Mahalanobis distance.</span>
<span class="sd">   minkowski        -- the Minkowski distance.</span>
<span class="sd">   seuclidean       -- the normalized Euclidean distance.</span>
<span class="sd">   sqeuclidean      -- the squared Euclidean distance.</span>
<span class="sd">   wminkowski       -- (deprecated) alias of `minkowski`.</span>

<span class="sd">Distance functions between two boolean vectors (representing sets) ``u`` and</span>
<span class="sd">``v``.  As in the case of numerical vectors, ``pdist`` is more efficient for</span>
<span class="sd">computing the distances between all pairs.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   dice             -- the Dice dissimilarity.</span>
<span class="sd">   hamming          -- the Hamming distance.</span>
<span class="sd">   jaccard          -- the Jaccard distance.</span>
<span class="sd">   kulsinski        -- the Kulsinski distance.</span>
<span class="sd">   rogerstanimoto   -- the Rogers-Tanimoto dissimilarity.</span>
<span class="sd">   russellrao       -- the Russell-Rao dissimilarity.</span>
<span class="sd">   sokalmichener    -- the Sokal-Michener dissimilarity.</span>
<span class="sd">   sokalsneath      -- the Sokal-Sneath dissimilarity.</span>
<span class="sd">   yule             -- the Yule dissimilarity.</span>

<span class="sd">:func:`hamming` also operates over discrete numerical vectors.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Copyright (C) Damian Eads, 2007-2008. New BSD License.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;braycurtis&#39;</span><span class="p">,</span>
    <span class="s1">&#39;canberra&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cdist&#39;</span><span class="p">,</span>
    <span class="s1">&#39;chebyshev&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cityblock&#39;</span><span class="p">,</span>
    <span class="s1">&#39;correlation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dice&#39;</span><span class="p">,</span>
    <span class="s1">&#39;directed_hausdorff&#39;</span><span class="p">,</span>
    <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
    <span class="s1">&#39;hamming&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_valid_dm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_valid_y&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jaccard&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jensenshannon&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kulsinski&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mahalanobis&#39;</span><span class="p">,</span>
    <span class="s1">&#39;matching&#39;</span><span class="p">,</span>
    <span class="s1">&#39;minkowski&#39;</span><span class="p">,</span>
    <span class="s1">&#39;num_obs_dm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;num_obs_y&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pdist&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">,</span>
    <span class="s1">&#39;russellrao&#39;</span><span class="p">,</span>
    <span class="s1">&#39;seuclidean&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sokalmichener&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sokalsneath&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sqeuclidean&#39;</span><span class="p">,</span>
    <span class="s1">&#39;squareform&#39;</span><span class="p">,</span>
    <span class="s1">&#39;wminkowski&#39;</span><span class="p">,</span>
    <span class="s1">&#39;yule&#39;</span>
<span class="p">]</span>


<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">scipy._lib.six</span> <span class="k">import</span> <span class="n">callable</span><span class="p">,</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">scipy._lib.six</span> <span class="k">import</span> <span class="n">xrange</span>
<span class="kn">from</span> <span class="nn">scipy._lib._util</span> <span class="k">import</span> <span class="n">_asarray_validated</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_distance_wrap</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_hausdorff</span>
<span class="kn">from</span> <span class="nn">..linalg</span> <span class="k">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">..special</span> <span class="k">import</span> <span class="n">rel_entr</span>


<span class="k">def</span> <span class="nf">_args_to_kwargs_xdist</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">func_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert legacy positional arguments to keyword arguments for pdist/cdist.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="ow">and</span> <span class="n">metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">braycurtis</span><span class="p">,</span> <span class="n">canberra</span><span class="p">,</span> <span class="n">chebyshev</span><span class="p">,</span> <span class="n">cityblock</span><span class="p">,</span> <span class="n">correlation</span><span class="p">,</span> <span class="n">cosine</span><span class="p">,</span>
            <span class="n">dice</span><span class="p">,</span> <span class="n">euclidean</span><span class="p">,</span> <span class="n">hamming</span><span class="p">,</span> <span class="n">jaccard</span><span class="p">,</span> <span class="n">jensenshannon</span><span class="p">,</span> <span class="n">kulsinski</span><span class="p">,</span>
            <span class="n">mahalanobis</span><span class="p">,</span> <span class="n">matching</span><span class="p">,</span> <span class="n">minkowski</span><span class="p">,</span> <span class="n">rogerstanimoto</span><span class="p">,</span> <span class="n">russellrao</span><span class="p">,</span>
            <span class="n">seuclidean</span><span class="p">,</span> <span class="n">sokalmichener</span><span class="p">,</span> <span class="n">sokalsneath</span><span class="p">,</span> <span class="n">sqeuclidean</span><span class="p">,</span> <span class="n">yule</span><span class="p">,</span>
            <span class="n">wminkowski</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;When using a custom metric arguments must be passed&#39;</span>
                        <span class="s1">&#39;as keyword (i.e., ARGNAME=ARGVALUE)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">func_name</span> <span class="o">==</span> <span class="s1">&#39;pdist&#39;</span><span class="p">:</span>
        <span class="n">old_arg_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;VI&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">old_arg_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;VI&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">]</span>

    <span class="n">num_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> metric parameters have been passed as positional.&#39;</span>
                  <span class="s1">&#39;This will raise an error in a future version.&#39;</span>
                  <span class="s1">&#39;Please pass arguments as keywords(i.e., ARGNAME=ARGVALUE)&#39;</span>
                  <span class="o">%</span> <span class="n">num_args</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_args</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Deprecated </span><span class="si">%s</span><span class="s1"> signature accepts only 4&#39;</span>
                         <span class="s1">&#39;positional arguments (</span><span class="si">%s</span><span class="s1">), </span><span class="si">%d</span><span class="s1"> given.&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">old_arg_names</span><span class="p">),</span> <span class="n">num_args</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">old_arg</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">old_arg_names</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">old_arg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">() got multiple values for argument </span><span class="si">%s</span><span class="s1">&#39;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">old_arg</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="n">old_arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_copy_array_if_base_present</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Copy the array if its base points to a parent array.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_correlation_cdist_wrap</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">XA</span> <span class="o">=</span> <span class="n">XA</span> <span class="o">-</span> <span class="n">XA</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">XB</span> <span class="o">=</span> <span class="n">XB</span> <span class="o">-</span> <span class="n">XB</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_cosine_double_wrap</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_correlation_pdist_wrap</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">X2</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_cosine_double_wrap</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_convert_to_type</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">out_type</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_type</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_filter_deprecated_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">args_blacklist</span><span class="p">):</span>
    <span class="c1"># Filtering out old default keywords</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">args_blacklist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Got unexpected kwarg </span><span class="si">%s</span><span class="s1">. This will raise an error&#39;</span>
                          <span class="s1">&#39; in a future version.&#39;</span> <span class="o">%</span> <span class="n">k</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="o">~</span><span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="o">~</span><span class="n">v</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">&amp;</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="nb">int</span><span class="p">],</span> <span class="p">[</span><span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">])</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">v</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">not_u</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">not_u</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">u</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">*</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="o">~</span><span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="o">~</span><span class="n">v</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="nb">int</span><span class="p">],</span> <span class="p">[</span><span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">])</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">v</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">not_u</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">not_u</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">u</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_cdist_input</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">metric_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># get supported types</span>
        <span class="n">types</span> <span class="o">=</span> <span class="n">_METRICS</span><span class="p">[</span><span class="n">metric_name</span><span class="p">]</span><span class="o">.</span><span class="n">types</span>
        <span class="c1"># choose best type</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">XA</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span> <span class="k">if</span> <span class="n">XA</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">types</span> <span class="k">else</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># validate data</span>
        <span class="n">XA</span> <span class="o">=</span> <span class="n">_convert_to_type</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">_convert_to_type</span><span class="p">(</span><span class="n">XB</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span>

        <span class="c1"># validate kwargs</span>
        <span class="n">_validate_kwargs</span> <span class="o">=</span> <span class="n">_METRICS</span><span class="p">[</span><span class="n">metric_name</span><span class="p">]</span><span class="o">.</span><span class="n">validator</span>
        <span class="k">if</span> <span class="n">_validate_kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_kwargs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">]),</span> <span class="n">mA</span> <span class="o">+</span> <span class="n">mB</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_validate_mahalanobis_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">VI</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;VI&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">VI</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="c1"># There are fewer observations than the dimension of</span>
            <span class="c1"># the observations.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of observations (</span><span class="si">%d</span><span class="s2">) is too &quot;</span>
                             <span class="s2">&quot;small; the covariance matrix is &quot;</span>
                             <span class="s2">&quot;singular. For observations with </span><span class="si">%d</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot;dimensions, at least </span><span class="si">%d</span><span class="s2"> observations &quot;</span>
                             <span class="s2">&quot;are required.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">CV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="n">VI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">CV</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;VI&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">VI</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_validate_minkowski_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;p&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_validate_pdist_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">metric_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># get supported types</span>
        <span class="n">types</span> <span class="o">=</span> <span class="n">_METRICS</span><span class="p">[</span><span class="n">metric_name</span><span class="p">]</span><span class="o">.</span><span class="n">types</span>
        <span class="c1"># choose best type</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span> <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">types</span> <span class="k">else</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># validate data</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">_convert_to_type</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span>

        <span class="c1"># validate kwargs</span>
        <span class="n">_validate_kwargs</span> <span class="o">=</span> <span class="n">_METRICS</span><span class="p">[</span><span class="n">metric_name</span><span class="p">]</span><span class="o">.</span><span class="n">validator</span>
        <span class="k">if</span> <span class="n">_validate_kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_validate_seuclidean_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Variance vector V must contain doubles.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Variance vector V must &#39;</span>
                             <span class="s1">&#39;be one-dimensional.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Variance vector V must be of the same &#39;</span>
                             <span class="s1">&#39;dimension as the vectors on which the distances &#39;</span>
                             <span class="s1">&#39;are computed.&#39;</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># XXX Is order=&#39;c&#39; really necessary?</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1"># Ensure values such as u=1 and u=[1] still return 1-D arrays.</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input vector should be 1-D.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>


<span class="k">def</span> <span class="nf">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">):</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input weights should be all non-negative&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w</span>


<span class="k">def</span> <span class="nf">_validate_wminkowski_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weighted minkowski requires a weight &#39;</span>
                         <span class="s1">&#39;vector `w` to be given.&#39;</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;p&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">directed_hausdorff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the directed Hausdorff distance between two N-D arrays.</span>

<span class="sd">    Distances between pairs are calculated using a Euclidean metric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (M,N) ndarray</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (O,N) ndarray</span>
<span class="sd">        Input array.</span>
<span class="sd">    seed : int or None</span>
<span class="sd">        Local `np.random.RandomState` seed. Default is 0, a random shuffling of</span>
<span class="sd">        u and v that guarantees reproducibility.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    d : double</span>
<span class="sd">        The directed Hausdorff distance between arrays `u` and `v`,</span>

<span class="sd">    index_1 : int</span>
<span class="sd">        index of point contributing to Hausdorff pair in `u`</span>

<span class="sd">    index_2 : int</span>
<span class="sd">        index of point contributing to Hausdorff pair in `v`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Uses the early break technique and the random sampling approach</span>
<span class="sd">    described by [1]_. Although worst-case performance is ``O(m * o)``</span>
<span class="sd">    (as with the brute force algorithm), this is unlikely in practice</span>
<span class="sd">    as the input data would have to require the algorithm to explore</span>
<span class="sd">    every single point interaction, and after the algorithm shuffles</span>
<span class="sd">    the input points at that. The best case performance is O(m), which</span>
<span class="sd">    is satisfied by selecting an inner loop distance that is less than</span>
<span class="sd">    cmax and leads to an early break as often as possible. The authors</span>
<span class="sd">    have formally shown that the average runtime is closer to O(m).</span>

<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] A. A. Taha and A. Hanbury, &quot;An efficient algorithm for</span>
<span class="sd">           calculating the exact Hausdorff distance.&quot; IEEE Transactions On</span>
<span class="sd">           Pattern Analysis And Machine Intelligence, vol. 37 pp. 2153-63,</span>
<span class="sd">           2015.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.spatial.procrustes : Another similarity test for two data sets</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the directed Hausdorff distance between two 2-D arrays of</span>
<span class="sd">    coordinates:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.spatial.distance import directed_hausdorff</span>
<span class="sd">    &gt;&gt;&gt; u = np.array([(1.0, 0.0),</span>
<span class="sd">    ...               (0.0, 1.0),</span>
<span class="sd">    ...               (-1.0, 0.0),</span>
<span class="sd">    ...               (0.0, -1.0)])</span>
<span class="sd">    &gt;&gt;&gt; v = np.array([(2.0, 0.0),</span>
<span class="sd">    ...               (0.0, 2.0),</span>
<span class="sd">    ...               (-2.0, 0.0),</span>
<span class="sd">    ...               (0.0, -4.0)])</span>

<span class="sd">    &gt;&gt;&gt; directed_hausdorff(u, v)[0]</span>
<span class="sd">    2.23606797749979</span>
<span class="sd">    &gt;&gt;&gt; directed_hausdorff(v, u)[0]</span>
<span class="sd">    3.0</span>

<span class="sd">    Find the general (symmetric) Hausdorff distance between two 2-D</span>
<span class="sd">    arrays of coordinates:</span>

<span class="sd">    &gt;&gt;&gt; max(directed_hausdorff(u, v)[0], directed_hausdorff(v, u)[0])</span>
<span class="sd">    3.0</span>

<span class="sd">    Find the indices of the points that generate the Hausdorff distance</span>
<span class="sd">    (the Hausdorff pair):</span>

<span class="sd">    &gt;&gt;&gt; directed_hausdorff(v, u)[1:]</span>
<span class="sd">    (3, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_hausdorff</span><span class="o">.</span><span class="n">directed_hausdorff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">minkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Minkowski distance between two 1-D arrays.</span>

<span class="sd">    The Minkowski distance between 1-D arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       {||u-v||}_p = (\\sum{|u_i - v_i|^p})^{1/p}.</span>


<span class="sd">       \\left(\\sum{w_i(|(u_i - v_i)|^p)}\\right)^{1/p}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    p : int</span>
<span class="sd">        The order of the norm of the difference :math:`{||u-v||}_p`.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    minkowski : double</span>
<span class="sd">        The Minkowski distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 0, 0], [0, 1, 0], 1)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 0, 0], [0, 1, 0], 2)</span>
<span class="sd">    1.4142135623730951</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 0, 0], [0, 1, 0], 3)</span>
<span class="sd">    1.2599210498948732</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 1, 0], [0, 1, 0], 1)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 1, 0], [0, 1, 0], 2)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 1, 0], [0, 1, 0], 3)</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;p must be at least 1&quot;</span><span class="p">)</span>
    <span class="n">u_v</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">root_w</span> <span class="o">=</span> <span class="n">w</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># better precision and speed</span>
            <span class="n">root_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">)</span>
        <span class="n">u_v</span> <span class="o">=</span> <span class="n">root_w</span> <span class="o">*</span> <span class="n">u_v</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">u_v</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dist</span>


<span class="c1"># `minkowski` gained weights in scipy 1.0.  Once we&#39;re at say version 1.3,</span>
<span class="c1"># deprecated `wminkowski`.  Not done at once because it would be annoying for</span>
<span class="c1"># downstream libraries that used `wminkowski` and support multiple scipy</span>
<span class="c1"># versions.</span>
<span class="k">def</span> <span class="nf">wminkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the weighted Minkowski distance between two 1-D arrays.</span>

<span class="sd">    The weighted Minkowski distance between `u` and `v`, defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\left(\\sum{(|w_i (u_i - v_i)|^p)}\\right)^{1/p}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    p : int</span>
<span class="sd">        The order of the norm of the difference :math:`{||u-v||}_p`.</span>
<span class="sd">    w : (N,) array_like</span>
<span class="sd">        The weight vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wminkowski : double</span>
<span class="sd">        The weighted Minkowski distance between vectors `u` and `v`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `wminkowski` is DEPRECATED. It implements a definition where weights</span>
<span class="sd">    are powered. It is recommended to use the weighted version of `minkowski`</span>
<span class="sd">    instead. This function will be removed in a future version of scipy.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.wminkowski([1, 0, 0], [0, 1, 0], 1, np.ones(3))</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; distance.wminkowski([1, 0, 0], [0, 1, 0], 2, np.ones(3))</span>
<span class="sd">    1.4142135623730951</span>
<span class="sd">    &gt;&gt;&gt; distance.wminkowski([1, 0, 0], [0, 1, 0], 3, np.ones(3))</span>
<span class="sd">    1.2599210498948732</span>
<span class="sd">    &gt;&gt;&gt; distance.wminkowski([1, 1, 0], [0, 1, 0], 1, np.ones(3))</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.wminkowski([1, 1, 0], [0, 1, 0], 2, np.ones(3))</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.wminkowski([1, 1, 0], [0, 1, 0], 3, np.ones(3))</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">minkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">euclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Euclidean distance between two 1-D arrays.</span>

<span class="sd">    The Euclidean distance between 1-D arrays `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       {||u-v||}_2</span>

<span class="sd">       \\left(\\sum{(w_i |(u_i - v_i)|^2)}\\right)^{1/2}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    euclidean : double</span>
<span class="sd">        The Euclidean distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.euclidean([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.4142135623730951</span>
<span class="sd">    &gt;&gt;&gt; distance.euclidean([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">minkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sqeuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the squared Euclidean distance between two 1-D arrays.</span>

<span class="sd">    The squared Euclidean distance between `u` and `v` is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       {||u-v||}_2^2</span>

<span class="sd">       \\left(\\sum{(w_i |(u_i - v_i)|^2)}\\right)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sqeuclidean : double</span>
<span class="sd">        The squared Euclidean distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.sqeuclidean([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; distance.sqeuclidean([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Preserve float dtypes, but convert everything else to np.float64</span>
    <span class="c1"># for stability.</span>
    <span class="n">utype</span><span class="p">,</span> <span class="n">vtype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)):</span>
        <span class="n">utype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)):</span>
        <span class="n">vtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">utype</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vtype</span><span class="p">)</span>
    <span class="n">u_v</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>
    <span class="n">u_v_w</span> <span class="o">=</span> <span class="n">u_v</span>  <span class="c1"># only want weights applied once</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">u_v_w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">u_v</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_v</span><span class="p">,</span> <span class="n">u_v_w</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">correlation</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the correlation distance between two 1-D arrays.</span>

<span class="sd">    The correlation distance between `u` and `v`, is</span>
<span class="sd">    defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">        1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}</span>
<span class="sd">                  {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}</span>

<span class="sd">    where :math:`\\bar{u}` is the mean of the elements of `u`</span>
<span class="sd">    and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    correlation : double</span>
<span class="sd">        The correlation distance between 1-D array `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">centered</span><span class="p">:</span>
        <span class="n">umu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="n">vmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">umu</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">vmu</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">uv</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uu</span> <span class="o">*</span> <span class="n">vv</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dist</span>


<span class="k">def</span> <span class="nf">cosine</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Cosine distance between 1-D arrays.</span>

<span class="sd">    The Cosine distance between `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">        1 - \\frac{u \\cdot v}</span>
<span class="sd">                  {||u||_2 ||v||_2}.</span>

<span class="sd">    where :math:`u \\cdot v` is the dot product of :math:`u` and</span>
<span class="sd">    :math:`v`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cosine : double</span>
<span class="sd">        The Cosine distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.cosine([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.cosine([100, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.cosine([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    0.29289321881345254</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># cosine distance is also referred to as &#39;uncentered correlation&#39;,</span>
    <span class="c1">#   or &#39;reflective correlation&#39;</span>
    <span class="k">return</span> <span class="n">correlation</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">hamming</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Hamming distance between two 1-D arrays.</span>

<span class="sd">    The Hamming distance between 1-D arrays `u` and `v`, is simply the</span>
<span class="sd">    proportion of disagreeing components in `u` and `v`. If `u` and `v` are</span>
<span class="sd">    boolean vectors, the Hamming distance is</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{c_{01} + c_{10}}{n}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hamming : double</span>
<span class="sd">        The Hamming distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.hamming([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    0.66666666666666663</span>
<span class="sd">    &gt;&gt;&gt; distance.hamming([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.33333333333333331</span>
<span class="sd">    &gt;&gt;&gt; distance.hamming([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    0.33333333333333331</span>
<span class="sd">    &gt;&gt;&gt; distance.hamming([1, 0, 0], [3, 0, 0])</span>
<span class="sd">    0.33333333333333331</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The 1d arrays must have equal lengths.&#39;</span><span class="p">)</span>
    <span class="n">u_ne_v</span> <span class="o">=</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">u_ne_v</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">jaccard</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Jaccard-Needham dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Jaccard-Needham dissimilarity between 1-D boolean arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{c_{TF} + c_{FT}}</span>
<span class="sd">            {c_{TT} + c_{FT} + c_{TF}}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jaccard : double</span>
<span class="sd">        The Jaccard distance between vectors `u` and `v`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When both `u` and `v` lead to a `0/0` division i.e. there is no overlap</span>
<span class="sd">    between the items in the vectors the returned distance is 0. See the</span>
<span class="sd">    Wikipedia page on the Jaccard index [1]_, and this paper [2]_.</span>

<span class="sd">    .. versionchanged:: 1.2.0</span>
<span class="sd">        Previously, when `u` and `v` lead to a `0/0` division, the function</span>
<span class="sd">        would return NaN. This was changed to return 0 instead.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Jaccard_index</span>
<span class="sd">    .. [2] S. Kosub, &quot;A note on the triangle inequality for the Jaccard</span>
<span class="sd">       distance&quot;, 2016, Available online: https://arxiv.org/pdf/1612.02696.pdf</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [1, 2, 0])</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [1, 1, 1])</span>
<span class="sd">    0.66666666666666663</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">unequal_nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">((</span><span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">),</span> <span class="n">nonzero</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">nonzero</span>
        <span class="n">unequal_nonzero</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">unequal_nonzero</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">unequal_nonzero</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nonzero</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">kulsinski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Kulsinski dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Kulsinski dissimilarity between two boolean 1-D arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">         \\frac{c_{TF} + c_{FT} - c_{TT} + n}</span>
<span class="sd">              {c_{FT} + c_{TF} + n}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kulsinski : double</span>
<span class="sd">        The Kulsinski distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.kulsinski([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.kulsinski([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.75</span>
<span class="sd">    &gt;&gt;&gt; distance.kulsinski([1, 0, 0], [2, 1, 0])</span>
<span class="sd">    0.33333333333333331</span>
<span class="sd">    &gt;&gt;&gt; distance.kulsinski([1, 0, 0], [3, 1, 0])</span>
<span class="sd">    -0.5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span> <span class="o">-</span> <span class="n">ntt</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">seuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the standardized Euclidean distance between two 1-D arrays.</span>

<span class="sd">    The standardized Euclidean distance between `u` and `v`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    V : (N,) array_like</span>
<span class="sd">        `V` is an 1-D array of component variances. It is usually computed</span>
<span class="sd">        among a larger collection vectors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    seuclidean : double</span>
<span class="sd">        The standardized Euclidean distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.seuclidean([1, 0, 0], [0, 1, 0], [0.1, 0.1, 0.1])</span>
<span class="sd">    4.4721359549995796</span>
<span class="sd">    &gt;&gt;&gt; distance.seuclidean([1, 0, 0], [0, 1, 0], [1, 0.1, 0.1])</span>
<span class="sd">    3.3166247903553998</span>
<span class="sd">    &gt;&gt;&gt; distance.seuclidean([1, 0, 0], [0, 1, 0], [10, 0.1, 0.1])</span>
<span class="sd">    3.1780497164141406</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;V must be a 1-D array of the same dimension &#39;</span>
                        <span class="s1">&#39;as u and v.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">euclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">V</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">cityblock</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the City Block (Manhattan) distance.</span>

<span class="sd">    Computes the Manhattan distance between two 1-D arrays `u` and `v`,</span>
<span class="sd">    which is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sum_i {\\left| u_i - v_i \\right|}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cityblock : double</span>
<span class="sd">        The City Block (Manhattan) distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.cityblock([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; distance.cityblock([1, 0, 0], [0, 2, 0])</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; distance.cityblock([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">l1_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">l1_diff</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">l1_diff</span>
    <span class="k">return</span> <span class="n">l1_diff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">mahalanobis</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">VI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Mahalanobis distance between two 1-D arrays.</span>

<span class="sd">    The Mahalanobis distance between 1-D arrays `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sqrt{ (u-v) V^{-1} (u-v)^T }</span>

<span class="sd">    where ``V`` is the covariance matrix.  Note that the argument `VI`</span>
<span class="sd">    is the inverse of ``V``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    VI : ndarray</span>
<span class="sd">        The inverse of the covariance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mahalanobis : double</span>
<span class="sd">        The Mahalanobis distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; iv = [[1, 0.5, 0.5], [0.5, 1, 0.5], [0.5, 0.5, 1]]</span>
<span class="sd">    &gt;&gt;&gt; distance.mahalanobis([1, 0, 0], [0, 1, 0], iv)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.mahalanobis([0, 2, 0], [0, 1, 0], iv)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.mahalanobis([2, 0, 0], [0, 1, 0], iv)</span>
<span class="sd">    1.7320508075688772</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">VI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">VI</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">VI</span><span class="p">),</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">chebyshev</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Chebyshev distance.</span>

<span class="sd">    Computes the Chebyshev distance between two 1-D arrays `u` and `v`,</span>
<span class="sd">    which is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\max_i {|u_i-v_i|}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input vector.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input vector.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chebyshev : double</span>
<span class="sd">        The Chebyshev distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.chebyshev([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; distance.chebyshev([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">has_weight</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">has_weight</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">has_weight</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">has_weight</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">braycurtis</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Bray-Curtis distance between two 1-D arrays.</span>

<span class="sd">    Bray-Curtis distance is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sum{|u_i-v_i|} / \\sum{|u_i+v_i|}</span>

<span class="sd">    The Bray-Curtis distance is in the range [0, 1] if all coordinates are</span>
<span class="sd">    positive, and is undefined if the inputs are of length zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    braycurtis : double</span>
<span class="sd">        The Bray-Curtis distance between 1-D arrays `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.braycurtis([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.braycurtis([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    0.33333333333333331</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">l1_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">l1_sum</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">l1_diff</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">l1_diff</span>
        <span class="n">l1_sum</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">l1_sum</span>
    <span class="k">return</span> <span class="n">l1_diff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">l1_sum</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">canberra</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Canberra distance between two 1-D arrays.</span>

<span class="sd">    The Canberra distance is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">         d(u,v) = \\sum_i \\frac{|u_i-v_i|}</span>
<span class="sd">                              {|u_i|+|v_i|}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    canberra : double</span>
<span class="sd">        The Canberra distance between vectors `u` and `v`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When `u[i]` and `v[i]` are 0 for given i, then the fraction 0/0 = 0 is</span>
<span class="sd">    used in the calculation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.canberra([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; distance.canberra([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">olderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">abs_uv</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">abs_u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">abs_v</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">abs_uv</span> <span class="o">/</span> <span class="p">(</span><span class="n">abs_u</span> <span class="o">+</span> <span class="n">abs_v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">d</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">olderr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">jensenshannon</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Jensen-Shannon distance (metric) between</span>
<span class="sd">    two 1-D probability arrays. This is the square root</span>
<span class="sd">    of the Jensen-Shannon divergence.</span>

<span class="sd">    The Jensen-Shannon distance between two probability</span>
<span class="sd">    vectors `p` and `q` is defined as,</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}}</span>

<span class="sd">    where :math:`m` is the pointwise mean of :math:`p` and :math:`q`</span>
<span class="sd">    and :math:`D` is the Kullback-Leibler divergence.</span>

<span class="sd">    This routine will normalize `p` and `q` if they don&#39;t sum to 1.0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : (N,) array_like</span>
<span class="sd">        left probability vector</span>
<span class="sd">    q : (N,) array_like</span>
<span class="sd">        right probability vector</span>
<span class="sd">    base : double, optional</span>
<span class="sd">        the base of the logarithm used to compute the output</span>
<span class="sd">        if not given, then the routine uses the default base of</span>
<span class="sd">        scipy.stats.entropy.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    js : double</span>
<span class="sd">        The Jensen-Shannon distance between `p` and `q`</span>

<span class="sd">    .. versionadded:: 1.2.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.jensenshannon([1.0, 0.0, 0.0], [0.0, 1.0, 0.0], 2.0)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.jensenshannon([1.0, 0.0], [0.5, 0.5])</span>
<span class="sd">    0.46450140402245893</span>
<span class="sd">    &gt;&gt;&gt; distance.jensenshannon([1.0, 0.0, 0.0], [1.0, 0.0, 0.0])</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">rel_entr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">rel_entr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">js</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">js</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">js</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">yule</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Yule dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Yule dissimilarity is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">         \\frac{R}{c_{TT} * c_{FF} + \\frac{R}{2}}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n` and :math:`R = 2.0 * c_{TF} * c_{FT}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    yule : double</span>
<span class="sd">        The Yule dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.yule([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; distance.yule([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ntf</span> <span class="o">*</span> <span class="n">nft</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ntt</span> <span class="o">*</span> <span class="n">nff</span> <span class="o">+</span> <span class="n">ntf</span> <span class="o">*</span> <span class="n">nft</span><span class="p">))</span>


<span class="nd">@np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s2">&quot;spatial.distance.matching is deprecated in scipy 1.0.0; &quot;</span>
                      <span class="s2">&quot;use spatial.distance.hamming instead.&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matching</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Hamming distance between two boolean 1-D arrays.</span>

<span class="sd">    This is a deprecated synonym for :func:`hamming`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hamming</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dice</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Dice dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Dice dissimilarity between `u` and `v`, is</span>

<span class="sd">    .. math::</span>

<span class="sd">         \\frac{c_{TF} + c_{FT}}</span>
<span class="sd">              {2c_{TT} + c_{FT} + c_{TF}}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) ndarray, bool</span>
<span class="sd">        Input 1-D array.</span>
<span class="sd">    v : (N,) ndarray, bool</span>
<span class="sd">        Input 1-D array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dice : double</span>
<span class="sd">        The Dice dissimilarity between 1-D arrays `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.dice([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.dice([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.3333333333333333</span>
<span class="sd">    &gt;&gt;&gt; distance.dice([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    -0.3333333333333333</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="nb">int</span><span class="p">],</span> <span class="p">[</span><span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">])</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ntt</span> <span class="o">+</span> <span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">rogerstanimoto</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Rogers-Tanimoto dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Rogers-Tanimoto dissimilarity between two boolean 1-D arrays</span>
<span class="sd">    `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">       \\frac{R}</span>
<span class="sd">            {c_{TT} + c_{FF} + R}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rogerstanimoto : double</span>
<span class="sd">        The Rogers-Tanimoto dissimilarity between vectors</span>
<span class="sd">        `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.rogerstanimoto([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    0.8</span>
<span class="sd">    &gt;&gt;&gt; distance.rogerstanimoto([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; distance.rogerstanimoto([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    -1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ntt</span> <span class="o">+</span> <span class="n">nff</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">russellrao</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Russell-Rao dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Russell-Rao dissimilarity between two boolean 1-D arrays, `u` and</span>
<span class="sd">    `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">      \\frac{n - c_{TT}}</span>
<span class="sd">           {n}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    russellrao : double</span>
<span class="sd">        The Russell-Rao dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.russellrao([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.russellrao([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.6666666666666666</span>
<span class="sd">    &gt;&gt;&gt; distance.russellrao([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    0.3333333333333333</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>


<span class="k">def</span> <span class="nf">sokalmichener</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Sokal-Michener dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Sokal-Michener dissimilarity between boolean 1-D arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{R}</span>
<span class="sd">            {S + R}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`, :math:`R = 2 * (c_{TF} + c_{FT})` and</span>
<span class="sd">    :math:`S = c_{FF} + c_{TT}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sokalmichener : double</span>
<span class="sd">        The Sokal-Michener dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalmichener([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    0.8</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalmichener([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalmichener([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    -1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">u</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ntt</span> <span class="o">+</span> <span class="n">nff</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">sokalsneath</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Sokal-Sneath dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Sokal-Sneath dissimilarity between `u` and `v`,</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{R}</span>
<span class="sd">            {c_{TT} + R}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sokalsneath : double</span>
<span class="sd">        The Sokal-Sneath dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.66666666666666663</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [2, 1, 0])</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [3, 1, 0])</span>
<span class="sd">    -2.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ntt</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">denom</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Sokal-Sneath dissimilarity is not defined for &#39;</span>
                         <span class="s1">&#39;vectors that are entirely false.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span> <span class="o">/</span> <span class="n">denom</span>


<span class="n">_convert_to_double</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_convert_to_type</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="n">_convert_to_bool</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_convert_to_type</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

<span class="c1"># adding python-only wrappers to _distance_wrap module</span>
<span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_correlation_double_wrap</span> <span class="o">=</span> <span class="n">_correlation_pdist_wrap</span>
<span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_correlation_double_wrap</span> <span class="o">=</span> <span class="n">_correlation_cdist_wrap</span>

<span class="c1"># Registry of implemented metrics:</span>
<span class="c1"># Dictionary with the following structure:</span>
<span class="c1"># {</span>
<span class="c1">#  metric_name : MetricInfo(aka, types=[double], validator=None)</span>
<span class="c1"># }</span>
<span class="c1">#</span>
<span class="c1"># Where:</span>
<span class="c1"># `metric_name` must be equal to python metric name</span>
<span class="c1">#</span>
<span class="c1"># MetricInfo is a named tuple with fields:</span>
<span class="c1">#  &#39;aka&#39; : [list of aliases],</span>
<span class="c1">#</span>
<span class="c1">#  &#39;validator&#39;: f(X, m, n, **kwargs)    # function that check kwargs and</span>
<span class="c1">#                                       # computes default values.</span>
<span class="c1">#</span>
<span class="c1">#  &#39;types&#39;: [list of supported types],  # X (pdist) and XA (cdist) are used to</span>
<span class="c1">#                                       # choose the type. if there is no match</span>
<span class="c1">#                                       # the first type is used. Default double</span>
<span class="c1"># }</span>
<span class="n">MetricInfo</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;MetricInfo&quot;</span><span class="p">,</span> <span class="s1">&#39;aka types validator &#39;</span><span class="p">)</span>
<span class="n">MetricInfo</span><span class="o">.</span><span class="fm">__new__</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;double&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>

<span class="n">_METRICS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;braycurtis&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;braycurtis&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;canberra&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;canberra&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;chebyshev&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;chebychev&#39;</span><span class="p">,</span> <span class="s1">&#39;chebyshev&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby&#39;</span><span class="p">,</span> <span class="s1">&#39;cheb&#39;</span><span class="p">,</span> <span class="s1">&#39;ch&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;cityblock&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s1">&#39;cblock&#39;</span><span class="p">,</span> <span class="s1">&#39;cb&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;correlation&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="s1">&#39;co&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;cosine&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;dice&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dice&#39;</span><span class="p">],</span> <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;euclidean&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;euclid&#39;</span><span class="p">,</span> <span class="s1">&#39;eu&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;hamming&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;matching&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;hamm&#39;</span><span class="p">,</span> <span class="s1">&#39;ha&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">],</span>
                          <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;double&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;jaccard&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;jacc&#39;</span><span class="p">,</span> <span class="s1">&#39;ja&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">],</span>
                          <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;double&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;jensenshannon&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jensenshannon&#39;</span><span class="p">,</span> <span class="s1">&#39;js&#39;</span><span class="p">],</span>
                                <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;double&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;kulsinski&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;kulsinski&#39;</span><span class="p">],</span> <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;mahalanobis&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mahalanobis&#39;</span><span class="p">,</span> <span class="s1">&#39;mahal&#39;</span><span class="p">,</span> <span class="s1">&#39;mah&#39;</span><span class="p">],</span>
                              <span class="n">validator</span><span class="o">=</span><span class="n">_validate_mahalanobis_kwargs</span><span class="p">),</span>
    <span class="s1">&#39;minkowski&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;minkowski&#39;</span><span class="p">,</span> <span class="s1">&#39;mi&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;pnorm&#39;</span><span class="p">],</span>
                            <span class="n">validator</span><span class="o">=</span><span class="n">_validate_minkowski_kwargs</span><span class="p">),</span>
    <span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">],</span> <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;russellrao&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;russellrao&#39;</span><span class="p">],</span> <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;seuclidean&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;seuclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;se&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">],</span>
                             <span class="n">validator</span><span class="o">=</span><span class="n">_validate_seuclidean_kwargs</span><span class="p">),</span>
    <span class="s1">&#39;sokalmichener&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sokalmichener&#39;</span><span class="p">],</span> <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;sokalsneath&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sokalsneath&#39;</span><span class="p">],</span> <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;sqeuclidean&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sqeuclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;sqe&#39;</span><span class="p">,</span> <span class="s1">&#39;sqeuclid&#39;</span><span class="p">]),</span>
    <span class="s1">&#39;wminkowski&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;wminkowski&#39;</span><span class="p">,</span> <span class="s1">&#39;wmi&#39;</span><span class="p">,</span> <span class="s1">&#39;wm&#39;</span><span class="p">,</span> <span class="s1">&#39;wpnorm&#39;</span><span class="p">],</span>
                             <span class="n">validator</span><span class="o">=</span><span class="n">_validate_wminkowski_kwargs</span><span class="p">),</span>
    <span class="s1">&#39;yule&#39;</span><span class="p">:</span> <span class="n">MetricInfo</span><span class="p">(</span><span class="n">aka</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;yule&#39;</span><span class="p">],</span> <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">]),</span>
<span class="p">}</span>


<span class="n">_METRIC_ALIAS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">alias</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                     <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">aka</span><span class="p">)</span>

<span class="n">_METRICS_NAMES</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_METRICS</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<span class="n">_TEST_METRICS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;test_&#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">:</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>


<span class="k">def</span> <span class="nf">_select_weighted_metric</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;w&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;w&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># w=None is the same as omitting it</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mstr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;wminkowski&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span><span class="p">:</span>
        <span class="c1"># These support weights</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="s2">&quot;w&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mstr</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;seuclidean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span> <span class="ow">or</span>
                <span class="n">mstr</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;mahalanobis&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;metric </span><span class="si">%s</span><span class="s2"> incompatible with weights&quot;</span> <span class="o">%</span> <span class="n">mstr</span><span class="p">)</span>

        <span class="c1"># XXX: C-versions do not support weights</span>
        <span class="c1"># need to use python version for weighting</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="s2">&quot;test_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">mstr</span>

    <span class="k">return</span> <span class="n">mstr</span><span class="p">,</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pairwise distances between observations in n-dimensional space.</span>

<span class="sd">    See Notes for common calling conventions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray</span>
<span class="sd">        An m by n array of m original observations in an</span>
<span class="sd">        n-dimensional space.</span>
<span class="sd">    metric : str or function, optional</span>
<span class="sd">        The distance metric to use. The distance function can</span>
<span class="sd">        be &#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;, &#39;cityblock&#39;,</span>
<span class="sd">        &#39;correlation&#39;, &#39;cosine&#39;, &#39;dice&#39;, &#39;euclidean&#39;, &#39;hamming&#39;,</span>
<span class="sd">        &#39;jaccard&#39;, &#39;jensenshannon&#39;, &#39;kulsinski&#39;, &#39;mahalanobis&#39;, &#39;matching&#39;,</span>
<span class="sd">        &#39;minkowski&#39;, &#39;rogerstanimoto&#39;, &#39;russellrao&#39;, &#39;seuclidean&#39;,</span>
<span class="sd">        &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;, &#39;yule&#39;.</span>
<span class="sd">    *args : tuple. Deprecated.</span>
<span class="sd">        Additional arguments should be passed as keyword arguments</span>
<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Extra arguments to `metric`: refer to each metric documentation for a</span>
<span class="sd">        list of all possible arguments.</span>

<span class="sd">        Some possible arguments:</span>

<span class="sd">        p : scalar</span>
<span class="sd">        The p-norm to apply for Minkowski, weighted and unweighted.</span>
<span class="sd">        Default: 2.</span>

<span class="sd">        w : ndarray</span>
<span class="sd">        The weight vector for metrics that support weights (e.g., Minkowski).</span>

<span class="sd">        V : ndarray</span>
<span class="sd">        The variance vector for standardized Euclidean.</span>
<span class="sd">        Default: var(X, axis=0, ddof=1)</span>

<span class="sd">        VI : ndarray</span>
<span class="sd">        The inverse of the covariance matrix for Mahalanobis.</span>
<span class="sd">        Default: inv(cov(X.T)).T</span>

<span class="sd">        out : ndarray.</span>
<span class="sd">        The output array</span>
<span class="sd">        If not None, condensed distance matrix Y is stored in this array.</span>
<span class="sd">        Note: metric independent, it will become a regular keyword arg in a</span>
<span class="sd">        future scipy version</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        Returns a condensed distance matrix Y.  For</span>
<span class="sd">        each :math:`i` and :math:`j` (where :math:`i&lt;j&lt;m`),where m is the number</span>
<span class="sd">        of original observations. The metric ``dist(u=X[i], v=X[j])``</span>
<span class="sd">        is computed and stored in entry ``ij``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    squareform : converts between condensed distance matrices and</span>
<span class="sd">                 square distance matrices.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See ``squareform`` for information on how to calculate the index of</span>
<span class="sd">    this entry or to convert the condensed distance matrix to a</span>
<span class="sd">    redundant square matrix.</span>

<span class="sd">    The following are common calling conventions.</span>

<span class="sd">    1. ``Y = pdist(X, &#39;euclidean&#39;)``</span>

<span class="sd">       Computes the distance between m points using Euclidean distance</span>
<span class="sd">       (2-norm) as the distance metric between the points. The points</span>
<span class="sd">       are arranged as m n-dimensional row vectors in the matrix X.</span>

<span class="sd">    2. ``Y = pdist(X, &#39;minkowski&#39;, p=2.)``</span>

<span class="sd">       Computes the distances using the Minkowski distance</span>
<span class="sd">       :math:`||u-v||_p` (p-norm) where :math:`p \\geq 1`.</span>

<span class="sd">    3. ``Y = pdist(X, &#39;cityblock&#39;)``</span>

<span class="sd">       Computes the city block or Manhattan distance between the</span>
<span class="sd">       points.</span>

<span class="sd">    4. ``Y = pdist(X, &#39;seuclidean&#39;, V=None)``</span>

<span class="sd">       Computes the standardized Euclidean distance. The standardized</span>
<span class="sd">       Euclidean distance between two n-vectors ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">          \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}</span>


<span class="sd">       V is the variance vector; V[i] is the variance computed over all</span>
<span class="sd">       the i&#39;th components of the points.  If not passed, it is</span>
<span class="sd">       automatically computed.</span>

<span class="sd">    5. ``Y = pdist(X, &#39;sqeuclidean&#39;)``</span>

<span class="sd">       Computes the squared Euclidean distance :math:`||u-v||_2^2` between</span>
<span class="sd">       the vectors.</span>

<span class="sd">    6. ``Y = pdist(X, &#39;cosine&#39;)``</span>

<span class="sd">       Computes the cosine distance between vectors u and v,</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{u \\cdot v}</span>
<span class="sd">                   {{||u||}_2 {||v||}_2}</span>

<span class="sd">       where :math:`||*||_2` is the 2-norm of its argument ``*``, and</span>
<span class="sd">       :math:`u \\cdot v` is the dot product of ``u`` and ``v``.</span>

<span class="sd">    7. ``Y = pdist(X, &#39;correlation&#39;)``</span>

<span class="sd">       Computes the correlation distance between vectors u and v. This is</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}</span>
<span class="sd">                   {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}</span>

<span class="sd">       where :math:`\\bar{v}` is the mean of the elements of vector v,</span>
<span class="sd">       and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.</span>

<span class="sd">    8. ``Y = pdist(X, &#39;hamming&#39;)``</span>

<span class="sd">       Computes the normalized Hamming distance, or the proportion of</span>
<span class="sd">       those vector elements between two n-vectors ``u`` and ``v``</span>
<span class="sd">       which disagree. To save memory, the matrix ``X`` can be of type</span>
<span class="sd">       boolean.</span>

<span class="sd">    9. ``Y = pdist(X, &#39;jaccard&#39;)``</span>

<span class="sd">       Computes the Jaccard distance between the points. Given two</span>
<span class="sd">       vectors, ``u`` and ``v``, the Jaccard distance is the</span>
<span class="sd">       proportion of those elements ``u[i]`` and ``v[i]`` that</span>
<span class="sd">       disagree.</span>

<span class="sd">    10. ``Y = pdist(X, &#39;chebyshev&#39;)``</span>

<span class="sd">       Computes the Chebyshev distance between the points. The</span>
<span class="sd">       Chebyshev distance between two n-vectors ``u`` and ``v`` is the</span>
<span class="sd">       maximum norm-1 distance between their respective elements. More</span>
<span class="sd">       precisely, the distance is given by</span>

<span class="sd">       .. math::</span>

<span class="sd">          d(u,v) = \\max_i {|u_i-v_i|}</span>

<span class="sd">    11. ``Y = pdist(X, &#39;canberra&#39;)``</span>

<span class="sd">       Computes the Canberra distance between the points. The</span>
<span class="sd">       Canberra distance between two points ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">         d(u,v) = \\sum_i \\frac{|u_i-v_i|}</span>
<span class="sd">                              {|u_i|+|v_i|}</span>


<span class="sd">    12. ``Y = pdist(X, &#39;braycurtis&#39;)``</span>

<span class="sd">       Computes the Bray-Curtis distance between the points. The</span>
<span class="sd">       Bray-Curtis distance between two points ``u`` and ``v`` is</span>


<span class="sd">       .. math::</span>

<span class="sd">            d(u,v) = \\frac{\\sum_i {|u_i-v_i|}}</span>
<span class="sd">                           {\\sum_i {|u_i+v_i|}}</span>

<span class="sd">    13. ``Y = pdist(X, &#39;mahalanobis&#39;, VI=None)``</span>

<span class="sd">       Computes the Mahalanobis distance between the points. The</span>
<span class="sd">       Mahalanobis distance between two points ``u`` and ``v`` is</span>
<span class="sd">       :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI``</span>
<span class="sd">       variable) is the inverse covariance. If ``VI`` is not None,</span>
<span class="sd">       ``VI`` will be used as the inverse covariance matrix.</span>

<span class="sd">    14. ``Y = pdist(X, &#39;yule&#39;)``</span>

<span class="sd">       Computes the Yule distance between each pair of boolean</span>
<span class="sd">       vectors. (see yule function documentation)</span>

<span class="sd">    15. ``Y = pdist(X, &#39;matching&#39;)``</span>

<span class="sd">       Synonym for &#39;hamming&#39;.</span>

<span class="sd">    16. ``Y = pdist(X, &#39;dice&#39;)``</span>

<span class="sd">       Computes the Dice distance between each pair of boolean</span>
<span class="sd">       vectors. (see dice function documentation)</span>

<span class="sd">    17. ``Y = pdist(X, &#39;kulsinski&#39;)``</span>

<span class="sd">       Computes the Kulsinski distance between each pair of</span>
<span class="sd">       boolean vectors. (see kulsinski function documentation)</span>

<span class="sd">    18. ``Y = pdist(X, &#39;rogerstanimoto&#39;)``</span>

<span class="sd">       Computes the Rogers-Tanimoto distance between each pair of</span>
<span class="sd">       boolean vectors. (see rogerstanimoto function documentation)</span>

<span class="sd">    19. ``Y = pdist(X, &#39;russellrao&#39;)``</span>

<span class="sd">       Computes the Russell-Rao distance between each pair of</span>
<span class="sd">       boolean vectors. (see russellrao function documentation)</span>

<span class="sd">    20. ``Y = pdist(X, &#39;sokalmichener&#39;)``</span>

<span class="sd">       Computes the Sokal-Michener distance between each pair of</span>
<span class="sd">       boolean vectors. (see sokalmichener function documentation)</span>

<span class="sd">    21. ``Y = pdist(X, &#39;sokalsneath&#39;)``</span>

<span class="sd">       Computes the Sokal-Sneath distance between each pair of</span>
<span class="sd">       boolean vectors. (see sokalsneath function documentation)</span>

<span class="sd">    22. ``Y = pdist(X, &#39;wminkowski&#39;, p=2, w=w)``</span>

<span class="sd">       Computes the weighted Minkowski distance between each pair of</span>
<span class="sd">       vectors. (see wminkowski function documentation)</span>

<span class="sd">    23. ``Y = pdist(X, f)``</span>

<span class="sd">       Computes the distance between all pairs of vectors in X</span>
<span class="sd">       using the user supplied 2-arity function f. For example,</span>
<span class="sd">       Euclidean distance between the vectors could be computed</span>
<span class="sd">       as follows::</span>

<span class="sd">         dm = pdist(X, lambda u, v: np.sqrt(((u-v)**2).sum()))</span>

<span class="sd">       Note that you should avoid passing a reference to one of</span>
<span class="sd">       the distance functions defined in this library. For example,::</span>

<span class="sd">         dm = pdist(X, sokalsneath)</span>

<span class="sd">       would calculate the pair-wise distances between the vectors in</span>
<span class="sd">       X using the Python function sokalsneath. This would result in</span>
<span class="sd">       sokalsneath being called :math:`{n \\choose 2}` times, which</span>
<span class="sd">       is inefficient. Instead, the optimized C version is more</span>
<span class="sd">       efficient, and we call it using the following syntax.::</span>

<span class="sd">         dm = pdist(X, &#39;sokalsneath&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># You can also call this as:</span>
    <span class="c1">#     Y = pdist(X, &#39;test_abc&#39;)</span>
    <span class="c1"># where &#39;abc&#39; is the metric being tested.  This computes the distance</span>
    <span class="c1"># between all pairs of vectors in X using the distance metric &#39;abc&#39; but</span>
    <span class="c1"># with a more succinct, verifiable, but less efficient implementation.</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sparse_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">objects_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_args_to_kwargs_xdist</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="s2">&quot;pdist&quot;</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;A 2-dimensional array must be passed.&#39;</span><span class="p">)</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;output array has incorrect shape.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output array must be C-contiguous.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output array must be double type.&quot;</span><span class="p">)</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># compute blacklist for deprecated kwargs</span>
    <span class="k">if</span><span class="p">(</span><span class="n">metric</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;jensenshannon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span>
       <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;test_jensenshannon&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">jensenshannon</span><span class="p">):</span>
        <span class="n">kwargs_blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;VI&quot;</span><span class="p">]</span>

    <span class="k">elif</span><span class="p">(</span><span class="n">metric</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;minkowski&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span>
         <span class="ow">or</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;wminkowski&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span>
         <span class="ow">or</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;test_minkowski&#39;</span><span class="p">,</span> <span class="s1">&#39;test_wminkowski&#39;</span><span class="p">]</span>
         <span class="ow">or</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="n">minkowski</span><span class="p">,</span> <span class="n">wminkowski</span><span class="p">]):</span>
        <span class="n">kwargs_blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;VI&quot;</span><span class="p">]</span>

    <span class="k">elif</span><span class="p">(</span><span class="n">metric</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;seuclidean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span> <span class="ow">or</span>
         <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;test_seuclidean&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">seuclidean</span><span class="p">):</span>
        <span class="n">kwargs_blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;VI&quot;</span><span class="p">]</span>

    <span class="k">elif</span><span class="p">(</span><span class="n">metric</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;mahalanobis&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span>
         <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;test_mahalanobis&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">mahalanobis</span><span class="p">):</span>
        <span class="n">kwargs_blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">kwargs_blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;VI&quot;</span><span class="p">]</span>

    <span class="n">_filter_deprecated_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">kwargs_blacklist</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;UnknownCustomMetric&#39;</span><span class="p">)</span>
        <span class="n">metric_name</span> <span class="o">=</span> <span class="n">_METRIC_ALIAS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">metric_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_pdist_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                                                   <span class="n">metric_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">mstr</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_select_weighted_metric</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

        <span class="n">metric_name</span> <span class="o">=</span> <span class="n">_METRIC_ALIAS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">metric_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_pdist_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                                                   <span class="n">metric_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># get pdist wrapper</span>
            <span class="n">pdist_fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_distance_wrap</span><span class="p">,</span>
                               <span class="s2">&quot;pdist_</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">_wrap&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">metric_name</span><span class="p">,</span> <span class="n">typ</span><span class="p">))</span>
            <span class="n">pdist_fn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dm</span>

        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;old_cosine&#39;</span><span class="p">,</span> <span class="s1">&#39;old_cos&#39;</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;&quot;old_cosine&quot; is deprecated and will be removed in &#39;</span>
                          <span class="s1">&#39;a future version. Use &quot;cosine&quot; instead.&#39;</span><span class="p">,</span>
                          <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norms</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">norms</span><span class="p">)</span>
            <span class="n">nV</span> <span class="o">=</span> <span class="n">norms</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># The numerator u * v</span>
            <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c1"># The denom. ||u||*||v||</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nV</span><span class="p">,</span> <span class="n">nV</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">nm</span> <span class="o">/</span> <span class="n">de</span><span class="p">)</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="n">_TEST_METRICS</span><span class="p">:</span>
                <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">_TEST_METRICS</span><span class="p">[</span><span class="n">mstr</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown &quot;Test&quot; Distance Metric: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mstr</span><span class="p">[</span><span class="mi">5</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown Distance Metric: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mstr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;2nd argument metric must be a string identifier &#39;</span>
                        <span class="s1">&#39;or a function.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dm</span>


<span class="k">def</span> <span class="nf">squareform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="s2">&quot;no&quot;</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a vector-form distance vector to a square-form distance</span>
<span class="sd">    matrix, and vice-versa.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray</span>
<span class="sd">        Either a condensed or redundant distance matrix.</span>
<span class="sd">    force : str, optional</span>
<span class="sd">        As with MATLAB(TM), if force is equal to ``&#39;tovector&#39;`` or</span>
<span class="sd">        ``&#39;tomatrix&#39;``, the input will be treated as a distance matrix or</span>
<span class="sd">        distance vector respectively.</span>
<span class="sd">    checks : bool, optional</span>
<span class="sd">        If set to False, no checks will be made for matrix</span>
<span class="sd">        symmetry nor zero diagonals. This is useful if it is known that</span>
<span class="sd">        ``X - X.T1`` is small and ``diag(X)`` is close to zero.</span>
<span class="sd">        These values are ignored any way so they do not disrupt the</span>
<span class="sd">        squareform transformation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        If a condensed distance matrix is passed, a redundant one is</span>
<span class="sd">        returned, or if a redundant one is passed, a condensed distance</span>
<span class="sd">        matrix is returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    1. v = squareform(X)</span>

<span class="sd">       Given a square d-by-d symmetric distance matrix X,</span>
<span class="sd">       ``v = squareform(X)`` returns a ``d * (d-1) / 2`` (or</span>
<span class="sd">       :math:`{n \\choose 2}`) sized vector v.</span>

<span class="sd">      :math:`v[{n \\choose 2}-{n-i \\choose 2} + (j-i-1)]` is the distance</span>
<span class="sd">      between points i and j. If X is non-square or asymmetric, an error</span>
<span class="sd">      is returned.</span>

<span class="sd">    2. X = squareform(v)</span>

<span class="sd">      Given a ``d*(d-1)/2`` sized v for some integer ``d &gt;= 2`` encoding</span>
<span class="sd">      distances as described, ``X = squareform(v)`` returns a d by d distance</span>
<span class="sd">      matrix X.  The ``X[i, j]`` and ``X[j, i]`` values are set to</span>
<span class="sd">      :math:`v[{n \\choose 2}-{n-i \\choose 2} + (j-i-1)]` and all</span>
<span class="sd">      diagonal elements are zero.</span>

<span class="sd">    In Scipy 0.19.0, ``squareform`` stopped casting all input types to</span>
<span class="sd">    float64, and started returning arrays of the same dtype as the input.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">force</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tomatrix&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Forcing &#39;tomatrix&#39; but input X is not a &quot;</span>
                             <span class="s2">&quot;distance vector.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">force</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tovector&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Forcing &#39;tovector&#39; but input X is not a &quot;</span>
                             <span class="s2">&quot;distance matrix.&quot;</span><span class="p">)</span>

    <span class="c1"># X = squareform(v)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Grab the closest value to the square root of the number</span>
        <span class="c1"># of elements times 2 to see if the number of elements</span>
        <span class="c1"># is indeed a binomial coefficient.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="c1"># Check that v is of valid dimensions.</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incompatible vector size. It must be a binomial &#39;</span>
                             <span class="s1">&#39;coefficient n choose 2 for some integer n &gt;= 2.&#39;</span><span class="p">)</span>

        <span class="c1"># Allocate memory for the distance matrix.</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Since the C code does not support striding using strides.</span>
        <span class="c1"># The dimensions are used instead.</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">_copy_array_if_base_present</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Fill in the values of the distance matrix.</span>
        <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">to_squareform_from_vector_wrap</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>

        <span class="c1"># Return the distance matrix.</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The matrix argument must be square.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">checks</span><span class="p">:</span>
            <span class="n">is_valid_dm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># One-side of the dimensions is set here.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Create a vector.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Since the C code does not support striding using strides.</span>
        <span class="c1"># The dimensions are used instead.</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">_copy_array_if_base_present</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Convert the vector to squareform.</span>
        <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">to_vector_from_squareform_wrap</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;The first argument must be one or two dimensional &#39;</span>
                          <span class="s1">&#39;array. A </span><span class="si">%d</span><span class="s1">-dimensional array is not &#39;</span>
                          <span class="s1">&#39;permitted&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">is_valid_dm</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">warning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if input array is a valid distance matrix.</span>

<span class="sd">    Distance matrices must be 2-dimensional numpy arrays.</span>
<span class="sd">    They must have a zero-diagonal, and they must be symmetric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : ndarray</span>
<span class="sd">        The candidate object to test for validity.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The distance matrix should be symmetric. `tol` is the maximum</span>
<span class="sd">        difference between entries ``ij`` and ``ji`` for the distance</span>
<span class="sd">        metric to be considered symmetric.</span>
<span class="sd">    throw : bool, optional</span>
<span class="sd">        An exception is thrown if the distance matrix passed is not valid.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name of the variable to checked. This is useful if</span>
<span class="sd">        throw is set to True so the offending variable can be identified</span>
<span class="sd">        in the exception message when an exception is thrown.</span>
<span class="sd">    warning : bool, optional</span>
<span class="sd">        Instead of throwing an exception, a warning message is</span>
<span class="sd">        raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid : bool</span>
<span class="sd">        True if the variable `D` passed is a valid distance matrix.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Small numerical differences in `D` and `D.T` and non-zeroness of</span>
<span class="sd">    the diagonal are ignored if they are within the tolerance specified</span>
<span class="sd">    by `tol`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> must have shape=2 &#39;</span>
                                  <span class="s1">&#39;(i.e. be two-dimensional).&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Distance matrix must have shape=2 (i.e. &#39;</span>
                                 <span class="s1">&#39;be two-dimensional).&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tol</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span> <span class="o">==</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> must be &#39;</span>
                                     <span class="s1">&#39;symmetric.&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Distance matrix must be symmetric.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> diagonal must &#39;</span>
                                      <span class="s1">&#39;be zero.&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Distance matrix diagonal must be zero.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span> <span class="o">-</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> must be &#39;</span>
                                      <span class="s1">&#39;symmetric within tolerance </span><span class="si">%5.5f</span><span class="s1">.&#39;</span><span class="p">)</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Distance matrix must be symmetric within&#39;</span>
                                     <span class="s1">&#39; tolerance </span><span class="si">%5.5f</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> diagonal must be&#39;</span>
                                      <span class="s1">&#39; close to zero within tolerance </span><span class="si">%5.5f</span><span class="s1">.&#39;</span><span class="p">)</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> diagonal must be&#39;</span>
                                      <span class="s1">&#39; close to zero within tolerance </span><span class="si">%5.5f</span><span class="s1">.&#39;</span><span class="p">)</span>
                                     <span class="o">%</span> <span class="n">tol</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">throw</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">warning</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">valid</span>


<span class="k">def</span> <span class="nf">is_valid_y</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">warning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if the input array is a valid condensed distance matrix.</span>

<span class="sd">    Condensed distance matrices must be 1-dimensional numpy arrays.</span>
<span class="sd">    Their length must be a binomial coefficient :math:`{n \\choose 2}`</span>
<span class="sd">    for some positive integer n.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The condensed distance matrix.</span>
<span class="sd">    warning : bool, optional</span>
<span class="sd">        Invokes a warning if the variable passed is not a valid</span>
<span class="sd">        condensed distance matrix. The warning message explains why</span>
<span class="sd">        the distance matrix is not valid.  `name` is used when</span>
<span class="sd">        referencing the offending variable.</span>
<span class="sd">    throw : bool, optional</span>
<span class="sd">        Throws an exception if the variable passed is not a valid</span>
<span class="sd">        condensed distance matrix.</span>
<span class="sd">    name : bool, optional</span>
<span class="sd">        Used when referencing the offending variable in the</span>
<span class="sd">        warning or exception message.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Condensed distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> must &#39;</span>
                                  <span class="s1">&#39;have shape=1 (i.e. be one-dimensional).&#39;</span><span class="p">)</span>
                                 <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Condensed distance matrix must have shape=1 &#39;</span>
                                 <span class="s1">&#39;(i.e. be one-dimensional).&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Length n of condensed distance matrix &#39;</span>
                                  <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> must be a binomial coefficient, i.e.&#39;</span>
                                  <span class="s1">&#39;there must be a k such that &#39;</span>
                                  <span class="s1">&#39;(k </span><span class="se">\\</span><span class="s1">choose 2)=n)!&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length n of condensed distance matrix must &#39;</span>
                                 <span class="s1">&#39;be a binomial coefficient, i.e. there must &#39;</span>
                                 <span class="s1">&#39;be a k such that (k </span><span class="se">\\</span><span class="s1">choose 2)=n)!&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">throw</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">warning</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">valid</span>


<span class="k">def</span> <span class="nf">num_obs_dm</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of original observations that correspond to a</span>
<span class="sd">    square, redundant distance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : ndarray</span>
<span class="sd">        The target distance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    num_obs_dm : int</span>
<span class="sd">        The number of observations in the redundant distance matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">is_valid_dm</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">num_obs_y</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of original observations that correspond to a</span>
<span class="sd">    condensed distance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        Condensed distance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of observations in the condensed distance matrix `Y`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">is_valid_y</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of observations cannot be determined on &quot;</span>
                         <span class="s2">&quot;an empty distance matrix.&quot;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid condensed distance matrix passed. Must be &quot;</span>
                         <span class="s2">&quot;some k where k=(n choose 2) for some n &gt;= 2.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute distance between each pair of the two collections of inputs.</span>

<span class="sd">    See Notes for common calling conventions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    XA : ndarray</span>
<span class="sd">        An :math:`m_A` by :math:`n` array of :math:`m_A`</span>
<span class="sd">        original observations in an :math:`n`-dimensional space.</span>
<span class="sd">        Inputs are converted to float type.</span>
<span class="sd">    XB : ndarray</span>
<span class="sd">        An :math:`m_B` by :math:`n` array of :math:`m_B`</span>
<span class="sd">        original observations in an :math:`n`-dimensional space.</span>
<span class="sd">        Inputs are converted to float type.</span>
<span class="sd">    metric : str or callable, optional</span>
<span class="sd">        The distance metric to use.  If a string, the distance function can be</span>
<span class="sd">        &#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;, &#39;cityblock&#39;, &#39;correlation&#39;,</span>
<span class="sd">        &#39;cosine&#39;, &#39;dice&#39;, &#39;euclidean&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &#39;jensenshannon&#39;,</span>
<span class="sd">        &#39;kulsinski&#39;, &#39;mahalanobis&#39;, &#39;matching&#39;, &#39;minkowski&#39;, &#39;rogerstanimoto&#39;,</span>
<span class="sd">        &#39;russellrao&#39;, &#39;seuclidean&#39;, &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;,</span>
<span class="sd">        &#39;wminkowski&#39;, &#39;yule&#39;.</span>
<span class="sd">    *args : tuple. Deprecated.</span>
<span class="sd">        Additional arguments should be passed as keyword arguments</span>
<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Extra arguments to `metric`: refer to each metric documentation for a</span>
<span class="sd">        list of all possible arguments.</span>

<span class="sd">        Some possible arguments:</span>

<span class="sd">        p : scalar</span>
<span class="sd">        The p-norm to apply for Minkowski, weighted and unweighted.</span>
<span class="sd">        Default: 2.</span>

<span class="sd">        w : ndarray</span>
<span class="sd">        The weight vector for metrics that support weights (e.g., Minkowski).</span>

<span class="sd">        V : ndarray</span>
<span class="sd">        The variance vector for standardized Euclidean.</span>
<span class="sd">        Default: var(vstack([XA, XB]), axis=0, ddof=1)</span>

<span class="sd">        VI : ndarray</span>
<span class="sd">        The inverse of the covariance matrix for Mahalanobis.</span>
<span class="sd">        Default: inv(cov(vstack([XA, XB].T))).T</span>

<span class="sd">        out : ndarray</span>
<span class="sd">        The output array</span>
<span class="sd">        If not None, the distance matrix Y is stored in this array.</span>
<span class="sd">        Note: metric independent, it will become a regular keyword arg in a</span>
<span class="sd">        future scipy version</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        A :math:`m_A` by :math:`m_B` distance matrix is returned.</span>
<span class="sd">        For each :math:`i` and :math:`j`, the metric</span>
<span class="sd">        ``dist(u=XA[i], v=XB[j])`` is computed and stored in the</span>
<span class="sd">        :math:`ij` th entry.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        An exception is thrown if `XA` and `XB` do not have</span>
<span class="sd">        the same number of columns.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following are common calling conventions:</span>

<span class="sd">    1. ``Y = cdist(XA, XB, &#39;euclidean&#39;)``</span>

<span class="sd">       Computes the distance between :math:`m` points using</span>
<span class="sd">       Euclidean distance (2-norm) as the distance metric between the</span>
<span class="sd">       points. The points are arranged as :math:`m`</span>
<span class="sd">       :math:`n`-dimensional row vectors in the matrix X.</span>

<span class="sd">    2. ``Y = cdist(XA, XB, &#39;minkowski&#39;, p=2.)``</span>

<span class="sd">       Computes the distances using the Minkowski distance</span>
<span class="sd">       :math:`||u-v||_p` (:math:`p`-norm) where :math:`p \\geq 1`.</span>

<span class="sd">    3. ``Y = cdist(XA, XB, &#39;cityblock&#39;)``</span>

<span class="sd">       Computes the city block or Manhattan distance between the</span>
<span class="sd">       points.</span>

<span class="sd">    4. ``Y = cdist(XA, XB, &#39;seuclidean&#39;, V=None)``</span>

<span class="sd">       Computes the standardized Euclidean distance. The standardized</span>
<span class="sd">       Euclidean distance between two n-vectors ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">          \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}.</span>

<span class="sd">       V is the variance vector; V[i] is the variance computed over all</span>
<span class="sd">       the i&#39;th components of the points. If not passed, it is</span>
<span class="sd">       automatically computed.</span>

<span class="sd">    5. ``Y = cdist(XA, XB, &#39;sqeuclidean&#39;)``</span>

<span class="sd">       Computes the squared Euclidean distance :math:`||u-v||_2^2` between</span>
<span class="sd">       the vectors.</span>

<span class="sd">    6. ``Y = cdist(XA, XB, &#39;cosine&#39;)``</span>

<span class="sd">       Computes the cosine distance between vectors u and v,</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{u \\cdot v}</span>
<span class="sd">                   {{||u||}_2 {||v||}_2}</span>

<span class="sd">       where :math:`||*||_2` is the 2-norm of its argument ``*``, and</span>
<span class="sd">       :math:`u \\cdot v` is the dot product of :math:`u` and :math:`v`.</span>

<span class="sd">    7. ``Y = cdist(XA, XB, &#39;correlation&#39;)``</span>

<span class="sd">       Computes the correlation distance between vectors u and v. This is</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}</span>
<span class="sd">                   {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}</span>

<span class="sd">       where :math:`\\bar{v}` is the mean of the elements of vector v,</span>
<span class="sd">       and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.</span>


<span class="sd">    8. ``Y = cdist(XA, XB, &#39;hamming&#39;)``</span>

<span class="sd">       Computes the normalized Hamming distance, or the proportion of</span>
<span class="sd">       those vector elements between two n-vectors ``u`` and ``v``</span>
<span class="sd">       which disagree. To save memory, the matrix ``X`` can be of type</span>
<span class="sd">       boolean.</span>

<span class="sd">    9. ``Y = cdist(XA, XB, &#39;jaccard&#39;)``</span>

<span class="sd">       Computes the Jaccard distance between the points. Given two</span>
<span class="sd">       vectors, ``u`` and ``v``, the Jaccard distance is the</span>
<span class="sd">       proportion of those elements ``u[i]`` and ``v[i]`` that</span>
<span class="sd">       disagree where at least one of them is non-zero.</span>

<span class="sd">    10. ``Y = cdist(XA, XB, &#39;chebyshev&#39;)``</span>

<span class="sd">       Computes the Chebyshev distance between the points. The</span>
<span class="sd">       Chebyshev distance between two n-vectors ``u`` and ``v`` is the</span>
<span class="sd">       maximum norm-1 distance between their respective elements. More</span>
<span class="sd">       precisely, the distance is given by</span>

<span class="sd">       .. math::</span>

<span class="sd">          d(u,v) = \\max_i {|u_i-v_i|}.</span>

<span class="sd">    11. ``Y = cdist(XA, XB, &#39;canberra&#39;)``</span>

<span class="sd">       Computes the Canberra distance between the points. The</span>
<span class="sd">       Canberra distance between two points ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">         d(u,v) = \\sum_i \\frac{|u_i-v_i|}</span>
<span class="sd">                              {|u_i|+|v_i|}.</span>

<span class="sd">    12. ``Y = cdist(XA, XB, &#39;braycurtis&#39;)``</span>

<span class="sd">       Computes the Bray-Curtis distance between the points. The</span>
<span class="sd">       Bray-Curtis distance between two points ``u`` and ``v`` is</span>


<span class="sd">       .. math::</span>

<span class="sd">            d(u,v) = \\frac{\\sum_i (|u_i-v_i|)}</span>
<span class="sd">                          {\\sum_i (|u_i+v_i|)}</span>

<span class="sd">    13. ``Y = cdist(XA, XB, &#39;mahalanobis&#39;, VI=None)``</span>

<span class="sd">       Computes the Mahalanobis distance between the points. The</span>
<span class="sd">       Mahalanobis distance between two points ``u`` and ``v`` is</span>
<span class="sd">       :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI``</span>
<span class="sd">       variable) is the inverse covariance. If ``VI`` is not None,</span>
<span class="sd">       ``VI`` will be used as the inverse covariance matrix.</span>

<span class="sd">    14. ``Y = cdist(XA, XB, &#39;yule&#39;)``</span>

<span class="sd">       Computes the Yule distance between the boolean</span>
<span class="sd">       vectors. (see `yule` function documentation)</span>

<span class="sd">    15. ``Y = cdist(XA, XB, &#39;matching&#39;)``</span>

<span class="sd">       Synonym for &#39;hamming&#39;.</span>

<span class="sd">    16. ``Y = cdist(XA, XB, &#39;dice&#39;)``</span>

<span class="sd">       Computes the Dice distance between the boolean vectors. (see</span>
<span class="sd">       `dice` function documentation)</span>

<span class="sd">    17. ``Y = cdist(XA, XB, &#39;kulsinski&#39;)``</span>

<span class="sd">       Computes the Kulsinski distance between the boolean</span>
<span class="sd">       vectors. (see `kulsinski` function documentation)</span>

<span class="sd">    18. ``Y = cdist(XA, XB, &#39;rogerstanimoto&#39;)``</span>

<span class="sd">       Computes the Rogers-Tanimoto distance between the boolean</span>
<span class="sd">       vectors. (see `rogerstanimoto` function documentation)</span>

<span class="sd">    19. ``Y = cdist(XA, XB, &#39;russellrao&#39;)``</span>

<span class="sd">       Computes the Russell-Rao distance between the boolean</span>
<span class="sd">       vectors. (see `russellrao` function documentation)</span>

<span class="sd">    20. ``Y = cdist(XA, XB, &#39;sokalmichener&#39;)``</span>

<span class="sd">       Computes the Sokal-Michener distance between the boolean</span>
<span class="sd">       vectors. (see `sokalmichener` function documentation)</span>

<span class="sd">    21. ``Y = cdist(XA, XB, &#39;sokalsneath&#39;)``</span>

<span class="sd">       Computes the Sokal-Sneath distance between the vectors. (see</span>
<span class="sd">       `sokalsneath` function documentation)</span>


<span class="sd">    22. ``Y = cdist(XA, XB, &#39;wminkowski&#39;, p=2., w=w)``</span>

<span class="sd">       Computes the weighted Minkowski distance between the</span>
<span class="sd">       vectors. (see `wminkowski` function documentation)</span>

<span class="sd">    23. ``Y = cdist(XA, XB, f)``</span>

<span class="sd">       Computes the distance between all pairs of vectors in X</span>
<span class="sd">       using the user supplied 2-arity function f. For example,</span>
<span class="sd">       Euclidean distance between the vectors could be computed</span>
<span class="sd">       as follows::</span>

<span class="sd">         dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))</span>

<span class="sd">       Note that you should avoid passing a reference to one of</span>
<span class="sd">       the distance functions defined in this library. For example,::</span>

<span class="sd">         dm = cdist(XA, XB, sokalsneath)</span>

<span class="sd">       would calculate the pair-wise distances between the vectors in</span>
<span class="sd">       X using the Python function `sokalsneath`. This would result in</span>
<span class="sd">       sokalsneath being called :math:`{n \\choose 2}` times, which</span>
<span class="sd">       is inefficient. Instead, the optimized C version is more</span>
<span class="sd">       efficient, and we call it using the following syntax::</span>

<span class="sd">         dm = cdist(XA, XB, &#39;sokalsneath&#39;)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the Euclidean distances between four 2-D coordinates:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; coords = [(35.0456, -85.2672),</span>
<span class="sd">    ...           (35.1174, -89.9711),</span>
<span class="sd">    ...           (35.9728, -83.9422),</span>
<span class="sd">    ...           (36.1667, -86.7833)]</span>
<span class="sd">    &gt;&gt;&gt; distance.cdist(coords, coords, &#39;euclidean&#39;)</span>
<span class="sd">    array([[ 0.    ,  4.7044,  1.6172,  1.8856],</span>
<span class="sd">           [ 4.7044,  0.    ,  6.0893,  3.3561],</span>
<span class="sd">           [ 1.6172,  6.0893,  0.    ,  2.8477],</span>
<span class="sd">           [ 1.8856,  3.3561,  2.8477,  0.    ]])</span>


<span class="sd">    Find the Manhattan distance from a 3-D point to the corners of the unit</span>
<span class="sd">    cube:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[0, 0, 0],</span>
<span class="sd">    ...               [0, 0, 1],</span>
<span class="sd">    ...               [0, 1, 0],</span>
<span class="sd">    ...               [0, 1, 1],</span>
<span class="sd">    ...               [1, 0, 0],</span>
<span class="sd">    ...               [1, 0, 1],</span>
<span class="sd">    ...               [1, 1, 0],</span>
<span class="sd">    ...               [1, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[ 0.1,  0.2,  0.4]])</span>
<span class="sd">    &gt;&gt;&gt; distance.cdist(a, b, &#39;cityblock&#39;)</span>
<span class="sd">    array([[ 0.7],</span>
<span class="sd">           [ 0.9],</span>
<span class="sd">           [ 1.3],</span>
<span class="sd">           [ 1.5],</span>
<span class="sd">           [ 1.5],</span>
<span class="sd">           [ 1.7],</span>
<span class="sd">           [ 2.1],</span>
<span class="sd">           [ 2.3]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># You can also call this as:</span>
    <span class="c1">#     Y = cdist(XA, XB, &#39;test_abc&#39;)</span>
    <span class="c1"># where &#39;abc&#39; is the metric being tested.  This computes the distance</span>
    <span class="c1"># between all pairs of vectors in XA and XB using the distance metric &#39;abc&#39;</span>
    <span class="c1"># but with a more succinct, verifiable, but less efficient implementation.</span>

    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_args_to_kwargs_xdist</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="s2">&quot;cdist&quot;</span><span class="p">)</span>

    <span class="n">XA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">XB</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">XA</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">sB</span> <span class="o">=</span> <span class="n">XB</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;XA must be a 2-dimensional array.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;XB must be a 2-dimensional array.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sB</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;XA and XB must have the same number of columns &#39;</span>
                         <span class="s1">&#39;(i.e. feature dimension.)&#39;</span><span class="p">)</span>

    <span class="n">mA</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mB</span> <span class="o">=</span> <span class="n">sB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output array has incorrect shape.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output array must be C-contiguous.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output array must be double type.&quot;</span><span class="p">)</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># compute blacklist for deprecated kwargs</span>
    <span class="k">if</span><span class="p">(</span><span class="n">metric</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;minkowski&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span> <span class="ow">or</span>
       <span class="n">metric</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;wminkowski&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span> <span class="ow">or</span>
       <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;test_minkowski&#39;</span><span class="p">,</span> <span class="s1">&#39;test_wminkowski&#39;</span><span class="p">]</span> <span class="ow">or</span>
       <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="n">minkowski</span><span class="p">,</span> <span class="n">wminkowski</span><span class="p">]):</span>
        <span class="n">kwargs_blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;VI&quot;</span><span class="p">]</span>
    <span class="k">elif</span><span class="p">(</span><span class="n">metric</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;seuclidean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span> <span class="ow">or</span>
         <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;test_seuclidean&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">seuclidean</span><span class="p">):</span>
        <span class="n">kwargs_blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;VI&quot;</span><span class="p">]</span>
    <span class="k">elif</span><span class="p">(</span><span class="n">metric</span> <span class="ow">in</span> <span class="n">_METRICS</span><span class="p">[</span><span class="s1">&#39;mahalanobis&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">aka</span> <span class="ow">or</span>
         <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;test_mahalanobis&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">mahalanobis</span><span class="p">):</span>
        <span class="n">kwargs_blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kwargs_blacklist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;VI&quot;</span><span class="p">]</span>

    <span class="n">_filter_deprecated_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">kwargs_blacklist</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>

        <span class="n">mstr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">)</span>
        <span class="n">metric_name</span> <span class="o">=</span> <span class="n">_METRIC_ALIAS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_cdist_input</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                                                    <span class="n">metric_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mB</span><span class="p">):</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">XA</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">XB</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">mstr</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_select_weighted_metric</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

        <span class="n">metric_name</span> <span class="o">=</span> <span class="n">_METRIC_ALIAS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">metric_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_cdist_input</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                                                        <span class="n">metric_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># get cdist wrapper</span>
            <span class="n">cdist_fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_distance_wrap</span><span class="p">,</span>
                               <span class="s2">&quot;cdist_</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">_wrap&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">metric_name</span><span class="p">,</span> <span class="n">typ</span><span class="p">))</span>
            <span class="n">cdist_fn</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dm</span>

        <span class="k">elif</span> <span class="n">mstr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="n">_TEST_METRICS</span><span class="p">:</span>
                <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">_TEST_METRICS</span><span class="p">[</span><span class="n">mstr</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown &quot;Test&quot; Distance Metric: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mstr</span><span class="p">[</span><span class="mi">5</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown Distance Metric: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mstr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;2nd argument metric must be a string identifier &#39;</span>
                        <span class="s1">&#39;or a function.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dm</span>
</pre></div>

          <footer>
  

  <hr/>

  <p style="font-size: 85%">
      Copyright &copy; 2019, Richard Gast, Daniel Rose, Christoph Salomon
    <br/>
    <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    <br/>
    These works by <a xmlns:cc="http://creativecommons.org/ns#" href="http://open.edx.org" property="cc:attributionName" rel="cc:attributionURL">edX Inc.</a>
    are licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
  </p>

 
</footer>
        </div>
      </div>

    </section>

  </div>
  
</body>
</html>